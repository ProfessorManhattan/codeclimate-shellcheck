{
  "SC1000": {
    "remediation_points": 50000,
    "content": {
      "body": "# $ is not used specially and should therefore be escaped.\n\n### Problematic code:\n\n```sh\necho \"$\"\n```\n\n### Correct code:\n\n```sh\necho \"\\$\"\n```\n\n### Rationale:\n`$` is special in double quotes, but there are some cases where it's interpreted literally:\n\n1. Following a backslash: `echo \"\\$\"`\n2. In a context where the shell can't make sense of it, such as at the end of the string, (`\"foo$\"`) or before some constructs (`\"$'foo'\"`).\n\nTo avoid relying on strange and shell specific behavior, any `$` intended to be literal should be escaped with a backslash.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1001": {
    "remediation_points": 50000,
    "content": {
      "body": "## This `\\c` will be a regular 'c' in this context.\n\n### Problematic code:\n\n```sh\necho Yay \\o/\n\\git status # Non-POSIX way to suppress aliases\n```\n\n### Correct code:\n\n```sh\necho 'Yay \\o/'\ncommand git status\n```\n\n### Rationale:\n\nEscaping something that doesn't need escaping sometimes indicates a bug.\n\nIf the backslash was supposed to be literal, single quote it.\n\nIf the purpose is to run an external command rather than an alias, prefer `command`.\n\n### Exceptions\n\nIf you have an alias and a function (as opposed to an external command), you can either ignore this message or use `\"name\"` instead of `\\name` to quiet ShellCheck.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1007": {
    "remediation_points": 50000,
    "content": {
      "body": "# Remove space after = if trying to assign a value (or for empty string, use var='' ... ).\n\n### Problematic code:\n\n```sh\n# I want programs to show text in dutch!\nLANGUAGE= nl\n```\n\n```sh\n# I want to run the nl command with English error messages!\nLANGUAGE= nl\n```\n\n### Correct code:\n\n```sh\n# I want programs to show text in dutch!\nLANGUAGE=nl\n```\n\n```sh\n# I want to run the nl command with English error messages!\nLANGUAGE='' nl\n```\n\n### Rationale:\n\nIt's easy to think that `LANGUAGE= nl` would assign `\"nl\"` to the variable `LANGUAGE`. It doesn't.\n\nInstead, it runs `nl` (the \"number lines\" command) and sets `LANGUAGE` to an empty string in its environment.\n\nSince trying to assign values this way is a common mistake, ShellCheck warns about it and asks you to be explicit when assigning empty strings (except for `IFS`, due to the common `IFS= read ..` idiom).\n\n### Exceptions\nIf you're familiar with this behavior and feel that the explicit version is unnecessary, you can [[ignore]] it.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1009": {
    "remediation_points": 50000,
    "content": {
      "body": "#  The mentioned parser error was in ...\n\nThis info warning points to the start of what ShellCheck was parsing when it failed. See [Parser Error](Parser Error) for example and information.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1010": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use semicolon or linefeed before 'done' (or quote to make it literal).\r\n\r\n### Problematic code:\r\n\r\nfor f in *; do echo \"$f\" done\r\n\r\n### Correct code:\r\n\r\nfor f in *; do echo \"$f\"; done\r\n\r\n### Rationale:\r\n\r\n`done` only works as a keyword when it's the first token of the command. If added after a command, it will just be the literal word \"done\". \r\n\r\n### Exceptions\r\n\r\nIf you're intentionally using `done` as a literal, you can quote it to make this clear to shellcheck (and also human readers), e.g. instead of `echo Task is done`, use `echo \"Task is done\"`. This makes no difference to the shell, but it will silence this warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1015": {
    "remediation_points": 50000,
    "content": {
      "body": "## This is a unicode double quote. Delete and retype it.\n\n### Problematic code:\n\n```sh\necho “hello world”\n```\n\n### Correct code:\n\n```sh\necho \"hello world\"\n```\n\n### Rationale:\n\nBlog software and word processors frequently replaces ASCII quotes `\"\"` with fancy Unicode quotes, `“”`. To bash, Unicode quotes are considered regular literals and not quotes at all.\n\nSimply delete them and retype them in your editor.\n\n### Exceptions\n\nIf you really want literal Unicode double quotes, you can put them in single quotes (or unicode single quotes in double quotes) to make shellcheck ignore them.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1016": {
    "remediation_points": 50000,
    "content": {
      "body": "## This is a unicode single quote. Delete and retype it.\n\n### Problematic code:\n\n```sh\necho ‘hello world’\n```\n\n### Correct code:\n\n```sh\necho 'hello world'\n```\n\n### Rationale:\n\nSome software, like OS X, Word and Wordpress, may automatically replace your regular quotes with slanted unicode quotes. Try deleting and retyping them, and/or disable \"smart quotes\" in your editor or OS.\n\n### Exceptions\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1018": {
    "remediation_points": 50000,
    "content": {
      "body": "# This is a unicode non-breaking space. Delete it and retype as space.\n\nYou copy-pasted some code, probably from a blog or web site, which for formatting reasons contained unicode no-break spaces or unicode zero-width spaces instead of regular spaces or in words.\n\nTo humans, a zero-width space is invisible and a non-breaking space is indistinguishable from a regular space, but the shell does not agree.\n\nIf you have just a few, delete the indiciated space/word and retype it. If you have tons, do a search&replace in your editor (copy-paste an offending space into the search field, and type a regular space into the replace field), or use `sed -e $'s/\\xC2\\xA0/ /g' -e $'s/\\xE2\\x80\\x8b//g' -i yourfile` to remove them.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1035": {
    "remediation_points": 50000,
    "content": {
      "body": "## You need a space here\n\n### Problematic code:\n\n```sh\nif ![-z foo ]; then true; fi # if command `[-z' w/ args `foo', `]' fails..\n```\n### Correct code:\n\n```sh\nif ! [ -z foo ]; then true; fi # if command `[' w/ args `-z', `foo', `]' fails..\n```\n\n### Rationale:\n\nBourne shells are very whitespace sensitive. Adding or removing spaces can drastically alter the meaning of a script. In these cases, ShellCheck has noticed that you're missing a space at the position indicated.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1037": {
    "remediation_points": 50000,
    "content": {
      "body": "## Braces are required for positionals over 9, e.g. ${10}.\n\n### Problematic code:\n\n```sh\necho \"Ninth parameter: $9\"\necho \"Tenth parameter: $10\"\n```\n\n### Correct code:\n\n```sh\necho \"Ninth parameter: $9\"\necho \"Tenth parameter: ${10}\"\n```\n\n### Rationale:\n\nFor legacy reasons, `$10` is interpreted as the variable `$1` followed by the literal string `0`.\n\nCurly braces are needed to tell the shell that both digits are part of the parameter expansion.\n\n### Exceptions\n\nIf you wanted the trailing digits to be literal, `${1}0` will make this clear to both humans and shellcheck.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1038": {
    "remediation_points": 50000,
    "content": {
      "body": "## Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.\n\n### Problematic code:\n\n```sh\nwhile IFS= read -r line\ndo\n  printf \"%q\\n\" \"$line\"\ndone <<(curl -s http://example.com)\n```\n\n### Correct code:\n\n```sh\nwhile IFS= read -r line\ndo\n  printf \"%q\\n\" \"$line\"\ndone <  <(curl -s http://example.com)\n```\n\n### Rationale:\n\nYou are using `<<(` which is an invalid construct.\n\nYou probably meant to redirect `<` from process substitution `<(..)` instead. To do this, a space is needed between the `<` and `<(..)`, i.e. `< <(cmd)`.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1040": {
    "remediation_points": 50000,
    "content": {
      "body": "## When using <<-, you can only indent with tabs.\n\n### Problematic code:\n\nAny code using `<<-` that is indented with spaces. `cat -T script` shows\n\n```sh\n    cat <<- foo\n        Hello world\n    foo\n```\n\n### Correct code:\n\nCode using `<<-` must be indented with tabs. `cat -T script` shows\n\n```sh\n^Icat <<- foo\n^I^IHello world\n^Ifoo\n```\n\nOr simply don't indent the end token:\n\n```sh\n    cat <<- foo\n      Hello World\nfoo\n```\n\n### Rationale:\n\n`<<-`, by design, only strips tabs. Not spaces.\n\nYour editor may be automatically replacing tabs with spaces, either when you type them or when you save the file or both. If you're unable to make it stop, just don't indent the end token.\n\n### Exceptions\n\nNone. But note that copy-pasting code to [shellcheck.net](http://www.shellcheck.net) may also turn correct tabs into spaces on some OS.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1044": {
    "remediation_points": 50000,
    "content": {
      "body": "**COULDN'T FIND THE END OF THE HERE DOC.** The starting Here tag must match the closing Here tag. \n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1045": {
    "remediation_points": 50000,
    "content": {
      "body": "# It's not 'foo &; bar', just 'foo & bar'.\n\n### Problematic code:\n\n```sh\nfoo &; bar\n```\n\n### Correct code:\n\n```sh\nfoo & bar\n```\n\n### Rationale:\n\nBoth `&` and `;` terminate the command. You should only use one of them.\n\n\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1065": {
    "remediation_points": 50000,
    "content": {
      "body": "## Trying to declare parameters? Don't. Use () and refer to params as $1, $2..\n\n### Problematic code:\n\n```sh\nfoo(input) {\n  echo \"$input\"\n}\nfoo(\"hello world\");\n```\n\n### Correct code:\n\n```sh\nfoo() {\n  echo \"$1\"\n}\nfoo \"hello world\"\n```\n\n### Rationale:\n\nShell script functions behave just like scripts and other commands:\n\n  - They always take a 0 to N parameters, referred to with `$1`, `$2` etc. They can not declare parameters by name.\n  - They are executed using `name arg1 arg2`, and not with parentheses as C-like languages.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1066": {
    "remediation_points": 50000,
    "content": {
      "body": "## Don't use $ on the left side of assignments.\n\n### Problematic code:\n\n```sh\n$greeting=\"Hello World\"\n```\n\n### Correct code:\n\n```sh\ngreeting=\"Hello World\"\n```\n\nAlternatively, if the goal was to assign to a variable whose name is in another variable (indirection), use `declare`:\n\n```sh\nname=foo\ndeclare \"$name=hello world\"\necho \"$foo\"\n```\n\n### Rationale:\n\nUnlike Perl or PHP, `$` is not used when assigning to a variable.\n\n### Exceptions\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1068": {
    "remediation_points": 50000,
    "content": {
      "body": "# Don't put spaces around the = in assignments.\n\n### Problematic code:\n\n```sh\nfoo = 42\n```\n\n### Correct code:\n\n```sh\nfoo=42\n```\n\n### Rationale:\n\nShells are space sensitive. `foo=42` means to assign `42` to the variable `foo`. `foo = 42` means to run a command named `foo`, and pass `=` as `$1` and `42` as `$2`.\n\n### Exceptions\n\nIf you actually wanted to run a command named foo and provide `=` as the first argument, simply quote it to make ShellCheck be quiet: `foo \"=\" 42`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1072": {
    "remediation_points": 50000,
    "content": {
      "body": "# Unexpected ..\n\nSee [Parser Error](Parser Error).\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1073": {
    "remediation_points": 50000,
    "content": {
      "body": "# Couldn't parse this ...\n\nThis parsing error points to the structure ShellCheck was trying to parse when a parser error occurred. See [Parser error](Parser error) for more information.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1077": {
    "remediation_points": 50000,
    "content": {
      "body": "# For command expansion, the tick should slant left (` vs ´).\n\n\n### Problematic code:\n\n```sh\necho \"Your username is ´whoami´\"\n```\n\n### Correct code:\n\n```sh\necho \"Your username is $(whoami)\" # Preferred\necho \"Your username is `whoami`\"  # Deprecated, will give [SC2006]\n```\n\n### Rationale:\n\nIn some fonts it's hard to tell ticks apart, but Bash strongly distinguishes between backticks (grave accent `` ` ``), forward ticks (acute accent `´`) and regular ticks (apostrophe `'`).\n\nBackticks start command expansions, while forward ticks are literal. To help spot bugs, ShellCheck parses backticks and forward ticks interchangeably.\n\n### Exceptions\n\nIf you want to write out literal forward ticks, such as fancyful ascii quotation marks:\n\n```sh\necho \"``Proprietary software is an injustice.´´  - Richard Stallman\"\n```\n\nuse single quotes instead:\n\n```sh\necho '``Proprietary software is an injustice.´´  - Richard Stallman'\n```\n\nTo nest forward ticks in command expansion, use `$(..)` instead of `` `..` ``.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1078": {
    "remediation_points": 50000,
    "content": {
      "body": "# Did you forget to close this double quoted string?\n\n### Problematic code:\n\n```sh\ngreeting=\"hello\ntarget=\"world\"\n```\n\n### Correct code:\n\n```sh\ngreeting=\"hello\"\ntarget=\"world\"\n```\n\n### Rationale:\n\nThe first line is missing a quote.\n\nShellCheck warns when it detects multi-line double quoted, single quoted or backticked strings when the character that follows it looks out of place (and gives a companion warning [[SC1079]] at that spot).\n\n### Exceptions\n\nIf you do want a multiline variable, just make sure the character after it is a quote, space or line feed.\n\n```sh\nvar='multiline\n'value\n```\n\ncan be rewritten for readability and to remove the warning:\n\n```sh\nvar='multiline\nvalue'\n```\n\nAs always `` `..` `` should be rewritten to ``$(..)``.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1079": {
    "remediation_points": 50000,
    "content": {
      "body": "## This is actually an end quote, but due to next char it looks suspect.\n\nSee companion warning [[SC1078]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1081": {
    "remediation_points": 50000,
    "content": {
      "body": "## Scripts are case sensitive. Use 'if', not 'If'.\n\n### Problematic code:\n\n```sh\nIf true\nThen\n  echo \"hello\"\nFi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"hello\"\nfi\n```\n\n### Rationale:\n\nShells are case sensitive and do not accept `If` or `IF` in place of lowercase `if`.\n\n### Exceptions\n\nIf you're aware of this and insist on naming a function `WHILE`, you can quote the name to prevent shellcheck from thinking you meant `while`. Or if you really want the names, add things like `alias If=if IF=if` to replace those keywords and ask shellcheck to ignore them.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1083": {
    "remediation_points": 50000,
    "content": {
      "body": "## This `{`/`}` is literal. Check expression (missing `;/\\n?`) or quote it.\n\n### Problematic code:\n\n```sh\nrmf() { rm -f \"$@\" }\n```\n\nor\n\n```sh\neval echo \\${foo}\n```\n\n### Correct code:\n\n```sh\nrmf() { rm -f \"$@\"; }\n```\n\nand\n\n```sh\neval \"echo \\${foo}\"\n```\n\n### Rationale:\n\nCurly brackets are normally used as syntax in parameter expansion, command grouping and brace expansion.\n\nHowever, if they don't appear alone at the start of an expression or as part of a parameter or brace expansion, the shell silently treats them as literals. This frequently indicates a bug, so ShellCheck warns about it.\n\nIn the example function, the `}` is literal because it's not at the start of an expression. We fix it by adding a `;` before it.\n\nIn the example eval, the code works fine. However, we can quiet the warning and follow good practice by adding quotes around the literal data.\n\nShellCheck does not warn about `{}`, since this is frequently used with `find` and rarely indicates a bug.\n\n### Exceptions\n\nThis error is harmless when the curly brackets are supposed to be literal, in e.g. `awk {'print $1'}`. However, it's cleaner and less error prone to simply include them inside the quotes: `awk '{print $1}'`.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1084": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use #!, not !#, for the shebang.\n\n### Problematic code:\n\n```sh\n!#/bin/sh\necho \"Hello World\"\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"Hello World\"\n```\n\n### Rationale:\n\nThe shebang has been accidentally swapped. The `#` should come first: `#!`, not `!#`.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1086": {
    "remediation_points": 50000,
    "content": {
      "body": "## Don't use $ on the iterator name in for loops.\n\n### Problematic code:\n\n```sh\nfor $var in *\ndo\n  echo \"$var\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor var in *\ndo\n  echo \"$var\"\ndone\n```\n\n### Rationale:\n\nThe variable is named `var`, and can be expanded to its value with `$var`.\n\nThe `for` loop expects the variable's name, not its value (and the name can not be specified indirectly).\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1087": {
    "remediation_points": 50000,
    "content": {
      "body": "## Braces are required when expanding arrays, as in ${array[idx]}.\n\n### Problematic code:\n\n```sh\necho \"$array[@]\"\n```\n\n### Correct code:\n\n```sh\necho \"${array[@]}\"\n```\n\n### Rationale:\n\nFor compatibility reasons, `$foo[bar]` is interpreted as the variable `$foo` followed by the literal string `[bar]`.\n\nCurly braces are needed to tell the shell that the square brackets are part of the expansion.\n\n### Exceptions\n\nIf you want the square brackets to be treated literally or as a glob, you can use `${var}[idx]` to prevent this warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1088": {
    "remediation_points": 50000,
    "content": {
      "body": "## Parsing stopped here. Invalid use of parentheses?\n\n### Problematic code:\n\n```sh\ngrep ^(.*)\\1$ file\n```\n\nor\n\n```sh\nvar = myfunction(value)\n```\n\n### Correct code:\n\n```sh\ngrep '^(.*)\\1$' file\n```\n\nor\n\n```sh\nvar=$(myfunction value)\n```\n\n### Rationale:\n\nParentheses are shell syntax and must be used correctly.\n\nFor commands that expect literal parentheses, such as `grep` or `find`, the parentheses need to be quoted or escaped so the shell does not interpret them, but instead passes them to the command.\n\nFor shell syntax, the shell does not use them the way most other languages do, so avoid guessing at syntax based on previous experience. In particular:\n\n- Parentheses are NOT used to call functions.\n- Parentheses are NOT used to group expressions, except in arithmetic contexts.\n- Parentheses are NOT used in conditional statements or loops.\n- Parentheses are used differently in different contexts. `( .. )`, `$( .. )`, `$(( .. ))` and `var=(..)` are completely separate and independent structures with different meanings, and can not be broken down into operations on expressions in parentheses.\n\n  In C-like languages, `++` can't be broken down into two `+` operations, so you can't e.g. use `+ +` or `+(+)`. In the same way, all of the above are completely unrelated so that you can't do `$(1+1)` or `$( (1+1) )` in place of `$(( 1+1 ))`.\n\nIf you are trying to use parentheses for shell syntax, look up the actual syntax of the statement you are trying to use.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1089": {
    "remediation_points": 50000,
    "content": {
      "body": "## Parsing stopped here. Is this keyword correctly matched up?\n\n### Problematic code:\n\n```sh\nif true\nthen\n  echo hello\nfi\nfi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo hello\nfi\n```\n\n### Rationale:\n\nThis error is typically seen when there are too many `fi`, `done` or `esac`s, or when there's a `do` or `then` without a corresponding `while`, `for` or `if`. This is often due to deleting a loop or conditional statement but not its terminator.\n\nIn some cases, it can even be caused by bad quoting:\n\n```sh\nvar=\"foo\nif [[ $var = \"bar ]\nthen\n  echo true\nfi\n```\n\nIn this case, the `if` ends up inside the double quotes, leaving the `then` dangling.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1090": {
    "remediation_points": 50000,
    "content": {
      "body": "## Can't follow non-constant source. Use a directive to specify location.\n\n### Problematic code:\n\n```sh\n. \"$(find_install_dir)/lib.sh\"\n```\n\n### Correct code:\n\n```sh\n# shellcheck source=src/lib.sh\n. \"$(find_install_dir)/lib.sh\"\n```\n\n### Rationale:\n\nShellCheck is not able to include sourced files from paths that are determined at runtime. The file will not be read, potentially resulting in warnings about unassigned variables and similar.\n\nUse a [[Directive]] to point shellcheck to a fixed location it can read instead.\n\n### Exceptions:\n\nIf you don't care that ShellCheck is unable to account for the file, specify `# shellcheck source=/dev/null`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1091": {
    "remediation_points": 50000,
    "content": {
      "body": "## Not following: (error message here)\n\nReasons include: file not found, no permissions, not included on the command line, not allowing `shellcheck` to follow files with `-x`, etc.\n\n### Problematic code:\n\n```sh\nsource somefile\n```\n\n### Correct code:\n\n```sh\n# shellcheck disable=SC1091\nsource somefile\n```\n\n### Rationale:\n\nShellCheck, for whichever reason, is not able to access the source file.\n\nThis could be because you did not include it on the command line, did not use `shellcheck -x` to allow following other files, don't have permissions or a variety of other problems.\n\nFeel free to ignore the error with a [[directive]].\n\n### Exceptions:\n\nIf you're fine with it, ignore the message with a [[directive]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1094": {
    "remediation_points": 50000,
    "content": {
      "body": "## Parsing of sourced file failed. Ignoring it.\n\n### Problematic code:\n\n```sh\nsource mylib\n```\n\n### Correct code:\n\n```sh\n# shellcheck disable=SC1094\nsource mylib\n```\n\n(or fix `mylib`)\n\n### Rationale:\n\nShellCheck encountered a parsing error in a sourced file, `mylib` in the example.\n\nFix parsing error, or just disable it with a directive.\n\n### Exceptions:\n\nIf the file is fine and this is due to a known `shellcheck` bug, you can ignore it with a [[directive]] as in the example.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1095": {
    "remediation_points": 50000,
    "content": {
      "body": "## You need a space or linefeed between the function name and body.\n\n### Problematic code:\n\n```sh\nfunction foo{\n  echo \"hello world\"\n}\n```\n\n### Correct code:\n\nPrefer POSIX syntax:\n```sh\nfoo() {\n  echo \"hello world\"\n}\n```\n\nAlternatively, add the missing space between function name and opening `{`:\n```sh\n#           v-- Here\nfunction foo {\n  echo \"hello world\"\n}\n```\n### Rationale:\n\nWhen using `function` keyword function definitions without `()`, a space is required between the function name and the opening `{`.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1097": {
    "remediation_points": 50000,
    "content": {
      "body": "## Unexpected ==. For assignment, use =. For comparison, use [/[[.\n\n### Problematic code:\n\n```sh\nvar==value\n```\n\n### Correct code:\n\nAssignment:\n\n```sh\nvar=value\n```\n\nComparison:\n\n```sh\n[ \"$var\" = value ]\n```\n\n### Rationale:\n\nShellCheck has noticed that you're using `==` in an unexpected way. The two most common reasons for this is:\n\n* You wanted to assign a value but accidentally used `==` instead of `=`.\n\n* You wanted to compare two values, but neglected to use `[ .. ]` or `[[ .. ]]`.\n\n### Exceptions:\n\nIf you wanted to assign a literal equals sign, use quotes to make this clear:\n\n```sh\nvar=\"=sum(A1:A10)\"\n```\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1098": {
    "remediation_points": 50000,
    "content": {
      "body": "## Quote/escape special characters when using eval, e.g. eval \"a=(b)\".\n\n### Problematic code:\n\n```sh\neval $var=(a b)\n```\n\n### Correct code:\n\n```sh\neval \"$var=(a b)\"\n```\n\n### Rationale:\n\nShells differ widely in how they handle unescaped parentheses in `eval` expressions.\n\n* `eval foo=bar` is allowed by dash, bash and ksh.\n* `eval foo=(bar)` is allowed by bash and ksh, but not dash.\n* `eval $var=(bar)` is allowed by ksh, but not bash or dash.\n* `eval foo() ( echo bar; )` is not allowed by any shell.\n\nSince the expression is evaluated as shell script code anyways, it should be passed in as a literal string without relying on special case parsing rules in the target shell. Quote/escape the characters accordingly.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC1099": {
    "remediation_points": 50000,
    "content": {
      "body": "## You need a space before the #.\n\n### Problematic code:\n\n```sh\nwhile sleep 1\ndo# show time\n  date\ndone\n```\n\n### Correct code:\n\n```sh\nwhile sleep 1\ndo # show time\n  date\ndone\n```\n\n### Rationale:\n\nShellCheck has noticed that you have a keyword immediately followed by a `#`. In order for the `#` to start a comment, it needs to come after a word boundary such as a space.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2001": {
    "remediation_points": 50000,
    "content": {
      "body": "## SC2001: See if you can use ${variable//search/replace} instead.\n\n### Problematic code:\n\n```sh\nstring=\"stirng\" ; echo \"$string\" | sed -e \"s/ir/ri/\"\n```\n\n### Correct code:\n\n```sh\nstring=\"stirng\" ; echo \"${string//ir/ri}\"\n```\n\n### Rationale:\n\nLet's assume somewhere earlier in your code you have put data into a variable (Ex: $string). Now you want to do a search and replace inside the contents of $string and echo the contents out. You could pass this to sed as done in the example above, but for simple substitutions utilizing the shell for the same feature is a lot simpler and should be utilized whenever possible.\n\n### Exceptions\n\nOccasionally a more complex sed substitution is required. For example, getting the last character of a string.\n\n```sh\nstring=\"stirng\" ; echo \"$string\" | sed -e \"s/^.*\\(.\\)$/\\1/\"\n```\n\nThis is a bit simple for the example and there are alternative ways of doing this in the shell, but this SC2001 flags on several of my crazy complex sed commands which are beyond the scope of this example. Utilizing some of the more complex capabilities of sed is required occasionally and it is safe to ignore SC2001.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2002": {
    "remediation_points": 50000,
    "content": {
      "body": "# Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.\n\n### Problematic code:\n\n```sh\ncat file | tr ' ' _ | grep a_\ncat file | ( while read i; do echo \"${i%?}\"; done )\n```\n\n### Correct code:\n\n```sh\n< file tr ' ' _ | grep a_  # **simple commands only, won't work with compounds\n( while read i; do echo \"${i%?}\"; done ) < file # postfix works for everything\n```\n\n### Rationale:\n\n`cat` is a tool for con\"cat\"enating files. Reading a single file as input to a program is considered a [Useless Use Of Cat (UUOC)](http://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat).\n\nIt's more efficient and less roundabout to simply use redirection. This is especially true for programs that can benefit from seekable input, like `tail` or `tar`.\n\nMany tools also accept optional filenames, e.g. `grep -q foo file` instead of `cat file | grep -q foo`.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2003": {
    "remediation_points": 50000,
    "content": {
      "body": "# expr is antiquated. Consider rewriting this using $((..)), ${} or [[ ]].\n\n### Problematic code:\n\n```sh\ni=$(expr 1 + 2)\nl=$(expr length \"$var\")\n```\n\n### Correct code:\n\n```sh\ni=$((1+2))\nl=${#var}\n```\n\n### Rationale:\n\n[To quote POSIX:](http://pubs.opengroup.org/onlinepubs/009695399/utilities/expr.html)\n\n> The expr utility has a rather difficult syntax [...] In many cases, the arithmetic and string features provided as part of the shell command language are easier to use than their equivalents in expr. Newly written scripts should avoid expr in favor of the new features within the shell.\n\n### Exceptions\n\n`sh` doesn't have a great replacement for the `:` operator (regex match). ShellCheck tries not to warn when using expr with `:`, but e.g. `op=:; expr string \"$op\" regex` still trigger it.\n\nOther than that, all uses of `expr` can be rewritten to use modern shell features instead.\n\nBash has `[[ string =~ regex ]]`, so not even `expr .. : ..` is necessary.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2004": {
    "remediation_points": 50000,
    "content": {
      "body": "# $/${} is unnecessary on arithmetic variables.\n\n### Problematic code:\n\n```sh\necho $(($n+1))\n```\n\n### Correct code:\n\n```sh\necho $((n+1))\n```\n\n### Rationale:\n\nThe `$` on regular variables in arithmetic contexts is unnecessary, and can even lead to subtle bugs. This is because the contents of `$((..))` is first expanded into a string, and then evaluated as an expression:\n\n```sh\n$ a='1+1'\n$ echo $(($a * 5))    # becomes 1+1*5\n6\n$ echo $((a * 5))     # evaluates as (1+1)*5\n10\n```\n\nThe `$` is unavoidable for special variables like `$1` vs `1`, `$#` vs `#`. ShellCheck does not warn about these cases.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2005": {
    "remediation_points": 50000,
    "content": {
      "body": "Useless `echo`? Instead of `echo $(cmd)`, just use `cmd`\n--------------------------------------------------------\n\n### Problematic code:\n\n```sh\necho \"$(cat 1.txt)\"\necho `< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c6`\n```\n\n### Correct code:\n\n```sh\ncat 1.txt # In bash, but faster and still sticks exactly one newline: printf '%s\\n' \"$(<1.txt)\"\n# The original `echo` sticks a newline; we want it too.\n< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c6; echo\n```\n\n### Rationale\n\nThe command substitution `$(foo)` yields the result of command `foo` with trailing newlines erased, and when it is passed to `echo` it generally just gives the same result as `foo`.\n\n### Exceptions\n\nOne may want to use command substitutions plus `echo` to make sure there is exactly one trailing newline. The special command substitution `$(<file)` in `bash` is also un-outline-able.\n\nAnyway, echo is still not that reliable (see [[SC2039#echo-flags]]) and `printf` should be used instead.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2006": {
    "remediation_points": 50000,
    "content": {
      "body": "# Use $(..) instead of legacy \\`..\\`\n\n### Problematic code\n\n```sh\necho \"Current time: `date`\"\n```\n\n### Correct code\n\n```sh\necho \"Current time: $(date)\"\n```\n\n### Rationale\n\nBacktick command substitution `` `..` `` is legacy syntax with several issues.\n\n1. It has a series of undefined behaviors related to quoting in POSIX.\n1. It imposes a custom escaping mode with surprising results.\n1. It's exceptionally hard to nest.\n\n`$(..)` command substitution has none of these problems, and is therefore strongly encouraged.\n\n### Exceptions\n\nNone.\n\n### See also\n\n- http://mywiki.wooledge.org/BashFAQ/082\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2008": {
    "remediation_points": 50000,
    "content": {
      "body": "## echo doesn't read from stdin, are you sure you should be piping to it?\n\n### Problematic code:\n\n```sh\nfind . | echo\n```\n\n### Correct code:\n\n```sh\nfind .\n```\n\n### Rationale:\n\nYou are piping command output to `echo`, but `echo` ignores all piped input.\n\nIn particular, `echo` is not responsible for putting output on screen. Commands already output data, and with no further actions that will end up on screen.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2009": {
    "remediation_points": 50000,
    "content": {
      "body": "## SC2009 Consider using pgrep instead of grepping ps output.\n\n### Problematic Code:\n\n```sh\nps ax | grep -v grep | grep \"$service\" > /dev/null\n```\n\n### Correct Code:\n\n```sh\npgrep -f \"$service\" > /dev/null\n```\n\n### Rationale:\n\nIf you are just after a pid from a running program, then pgrep is a much safer alternative. Especially if you are also looking for a pid belonging to a certain user or group. All of the parameters are in one command and it cat eliminate multiple greps, cuts, seds, awks, ect.\n\n### Exceptions\n\nWhat if you have the pid and you are looking for the matching program name?\n\n```sh\npid=123; ps ax | grep \"$pid\"\n```\n\nWhat if you want a range of the ps field, like from the 16th space to the end of the line?\n\n```sh\nps ax | grep \"$pid\" | cut -d\" \" -f16-\n```\n\nBoth are valid cases where SC2009 is not valid.\n\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2010": {
    "remediation_points": 50000,
    "content": {
      "body": "## Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2012": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use find instead of ls to better handle non-alphanumeric filenames.\n\n### Problematic code:\n\n```sh\nls -l | grep \" $USER \" | grep '\\.txt$'\n```\n\n### Correct code:\n\n```sh\nfind . -maxdepth 1 -name '*.txt' -user \"$USER\"\n```\n\n### Rationale:\n\n`ls` is only intended for human consumption: it has a loose, non-standard format and may \"clean up\" filenames to make output easier to read.\n\nHere's an example:\n\n```sh\n$ ls -l\ntotal 0\n-rw-r----- 1 me me 0 Feb  5 20:11 foo?bar\n-rw-r----- 1 me me 0 Feb  5  2011 foo?bar\n-rw-r----- 1 me me 0 Feb  5 20:11 foo?bar\n```\n\nIt shows three seemingly identical filenames, and did you spot the time format change? How it formats and what it redacts can differ between locale settings, `ls` version, and whether output is a tty.\n\n`ls` can usually be substituted for `find` if it's the filenames you're after.\n\nIf trying to parse out any other fields, first see whether `stat` (GNU, OS X, FreeBSD) or `find -printf` (GNU) can give you the data you want directly.\n\n### Exceptions:\n\nIf the information is intended for the user and not for processing (`ls -l ~/dir | nl; echo \"Ok to delete these files?\"`) you can ignore this error with a [[directive]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2013": {
    "remediation_points": 50000,
    "content": {
      "body": "# To read lines rather than words, pipe/redirect to a 'while read' loop.\n\n### Problematic code:\n\n```sh\nfor line in $(cat file | grep -v '^ *#')\ndo\n  echo \"Line: $line\"\ndone\n```\n\n### Correct code:\n\n```sh\ngrep -v '^ *#' < file | while IFS= read -r line\ndo\n  echo \"Line: $line\"\ndone\n```\n\nor without a subshell (bash, zsh, ksh):\n\n```sh\nwhile IFS= read -r line\ndo\n  echo \"Line: $line\"\ndone < <(grep -v '^ *#' < file)\n```\n\n### Rationale:\n\nFor loops by default (subject to `$IFS`) read word by word. Additionally, glob expansion will occur.\n\nGiven this text file:\n\n```sh\nfoo *\nbar\n```\n\nThe for loop will print:\n\n```sh\nLine: foo\nLine: aardwark.jpg\nLine: bullfrog.jpg\n...\n```\n\nThe while loop will print:\n\n```sh\nLine: foo *\nLine: bar\n```\n\n\n### Exceptions\n\nIf you want to read word by word, you should still use a while read loop (e.g. with `read -a` to read words into an array).\n\nRare reasons for ignoring this message is if you don't care because your file only contains numbers and you're not interested in good practices, or if you've set `$IFS` appropriately and also disabled globbing.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2014": {
    "remediation_points": 50000,
    "content": {
      "body": "## This will expand once before find runs, not per file found.\n\n### Problematic code:\n\n```sh\nfind . -name '*.tar' -exec tar xf {} -C \"$(dirname {})\" \\;\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.tar' -exec sh -c 'tar xf \"$1\" -C \"$(dirname \"$1\")\"' _ {} \\;\n```\n\n### Rationale:\n\nBash evaluates any command substitutions before the command they feature in is executed. In this case, the command is `find`. This means that `$(dirname {})` will run **before** `find` runs, and not **while** `find` runs.\n\nTo run shell code for each file, we can write a tiny script and inline it with `sh -c`. We add `_` as a dummy argument that becomes `$0`, and a filename argument that becomes `$1` in the inlined script:\n\n```sh\n$ sh -c 'echo \"$1 is in $(dirname \"$1\")\"' _ \"mydir/myfile\"\nmydir/myfile is in mydir\n```\n\nThis command can be executed by `find -exec`, with `{}` as the filename argument. It executes shell which interprets the inlined script once for each file. Note that the inlined script is single quoted, again to ensure that the expansion does not happen prematurely .\n\n### Exceptions:\n\nIf you don't care (or if you prefer) that it's only expanded once, like when dynamically selecting the executable to be used by all invocations, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2015": {
    "remediation_points": 50000,
    "content": {
      "body": "# Note that A && B || C is not if-then-else. C may run when A is true.\n\n### Problematic code:\n\n```sh\n[[ $dryrun ]] && echo \"Would delete file\" || rm file\n```\n\n### Correct code:\n\n```sh\nif [[ $dryrun ]]\nthen\n  echo \"Would delete file\"\nelse\n  rm file\nfi\n```\n\n### Rationale:\n\nIt's common to use `A && B` to run `B` when `A` is true, and `A || C` to run `C` when `A` is false.\n\nHowever, combining them into `A && B || C` is not the same as `if A then B else C`.\n\nIn this case, if `A` is true but `B` is false, `C` will run.\n\nFor the code sample above, if the script was run with stdout closed for any reason (such as explicitly running `script --dryrun >&-`), echo would fail and the file would be deleted, even though `$dryrun` was set!\n\nIf an `if` clause is used instead, this problem is avoided.\n\n### Exceptions\nIgnore this warning when you actually do intend to run C when either A or B fails.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2016": {
    "remediation_points": 50000,
    "content": {
      "body": "# Expressions don't expand in single quotes, use double quotes for that.\n\n### Problematic code:\n\n```sh\nname=World\necho 'Hello $name'\n```\n\n### Correct code:\n\n```sh\nname=World\necho \"Hello $name\"\n```\n\n### Rationale:\n\nSingle quotes prevent expansion of everything, including variables and command substitution.\n\nIf you want to use the values of variables and such, use double quotes instead.\n\nNote that if you have other items that needs single quoting, you can use both in a single word:\n\n```sh\necho '$1 USD is '\"$rate GBP\"\n```\n\n### Exceptions\n\nIf you want `$stuff` to be a literal dollar sign followed by the characters \"stuff\", you can ignore this message.\n\nShellCheck tries to be smart about it, and won't warn when this is used with awk, perl and similar, but there are some inherent ambiguities like `'I have $1 in my wallet'`, which could be \"one dollar\" or \"whatever's in the first parameter\".\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2017": {
    "remediation_points": 50000,
    "content": {
      "body": "## Increase precision by replacing a/b\\*c with a\\*c/b.\n\n### Problematic code:\n\n```sh\npercent=$((count/total*100))\n```\n\n### Correct code:\n\n```sh\npercent=$((count*100/total))\n```\n\n### Rationale:\n\nIf integer division is performed before multiplication, the intermediate result will be truncated causing a loss of precision.\n\nIn this case, if  `count=1` and `total=2`, then the problematic code results in `percent=0`, while the correct code gives `percent=50`.\n\n### Exceptions:\n\nIf you want and expect truncation you can ignore this message.\n\nShellCheck doesn't warn when `b` and `c` are identical expressions, e.g. `a/10*10`, under the assumption that the intent is to rounded to the nearest 10 rather than the no-op of multiply by `1`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2020": {
    "remediation_points": 50000,
    "content": {
      "body": "# tr replaces sets of chars, not words (mentioned due to duplicates).\n\n### Problematic code:\n\n```sh\necho 'hello world' | tr 'hello' 'goodbye'\n```\n\n### Correct code:\n\n```sh\necho 'hello world' | sed -e 's/hello/goodbye/g'\n```\n\n### Rationale:\n\n`tr` is for `tr`ansliteration, turning some characters into other characters. It doesn't match strings or words, only individual characters.\n\nIn this case, it transliterates h->g, e->o, l->d, o->y, resulting in the string \"goddb wbrdd\" instead of \"goodbye world\".\n\nThe solution is to use a tool that does string search and replace, such as sed.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2021": {
    "remediation_points": 50000,
    "content": {
      "body": "## Don't use [] around ranges in tr, it replaces literal square brackets.\n\n### Problematic code:\n\n```sh\ntr -cd '[a-z]'\n```\n\n### Correct code:\n\n```sh\ntr -cd 'a-z'\n```\n### Rationale:\n\nAncient System V `tr` required brackets around operands, but modern implementations including POSIX, GNU, OS X and *BSD instead treat them as literals.\n\nUnless you want to operate on literal square brackets, don't include them.\n\n### Exceptions:\n\nIf you do want to replace literal square brackets, reorder the expression (e.g. `a-z[]` to make it clear that the brackets are not special).\n\nShellCheck does not warn about correct usage of `[..]` in character and equivalence classes like `[:lower:]` and `[=e=]`.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2022": {
    "remediation_points": 50000,
    "content": {
      "body": "# Note that unlike globs, o* here matches 'ooo' but not 'oscar'\n### Problematic code:\n\n```sh\ngrep 'foo*'\n```\n\nwhen wanting to match `food` and `foosball`, but not `mofo` or `keyfob`.\n\n### Correct code:\n\n```sh\ngrep '^foo'\n```\n\n### Rationale:\n\nAs a glob, `foo*` means \"Any string starting with foo\", e.g. `food` and `foosball`.\n\nAs a regular expression, \"foo*\" means \"f followed by 1 or more o's, anywhere\", e.g. \"mofo\" or \"keyfob\".\n\nThis construct is way more common as a glob than as a regex, so ShellCheck notifies you about it.\n\n### Exceptions\n\nIf you're aware of the above, you can ignore this message. If you'd like shellcheck to be quiet, use a [[directive]] or `'fo[o]*'`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2024": {
    "remediation_points": 50000,
    "content": {
      "body": "## sudo doesn't affect redirects. Use ..| sudo tee file\r\n\r\n### Problematic code:\r\n\r\nsudo echo 'export FOO=bar' >> /etc/profile\r\n\r\n### Correct code:\r\n\r\necho 'export FOO=bar' | sudo tee -a /etc/profile > /dev/null\r\n\r\n### Rationale:\r\n\r\nRedirections are performed by the current shell before `sudo` is started. This means that it will use the current shell's user and permissions to open and write to the file.\r\n\r\n`tee` is a simple command that opens and writes to files without help from the shell, which means that it will use the permissions that `sudo` grants it.\r\n\r\nThere is nothing special about `tee`. It's just the simplest command that can both truncate and append to files without help from the shell. Here are equivalent alternatives:\r\n\r\nTruncating:\r\n\r\necho 'data' | sudo dd of=file\r\necho 'data' | sudo sed 'w file'\r\n\r\nAppending: \r\n\r\necho 'data' | sudo awk '{ print $0 >> \"file\" }'\r\necho 'data' | sudo sh -c 'cat >> file'\r\n\r\n\r\n### Exceptions\r\n\r\nIf you want to run a command as root but redirect as the normal user, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2025": {
    "remediation_points": 50000,
    "content": {
      "body": "# Make sure all escape sequences are enclosed in \\[..\\] to prevent line wrapping issues\n\n### Problematic code:\n\n```sh\nPS1='\\e[36m\\$ \\e(B\\e[m'\n```\n\n### Correct code:\n\n```sh\nPS1='\\[\\e[36m\\]\\$ \\[\\e(B\\e[m\\]'\n```\n\n### Rationale:\n\nBash is unable to determine exactly which parts of your prompt are text and which are terminal codes. You have to help it by wrapping invisible control codes in `\\[..\\]` (and ensuring that visible characters are not wrapped in `\\[..\\]`).\n\nNote: ShellCheck offers this as a helpful hint and not a robust check. Don't rely on ShellCheck to verify that your prompt is correct.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2026": {
    "remediation_points": 50000,
    "content": {
      "body": "## This word is outside of quotes. Did you intend to `'nest '\"'single quotes'\"'` instead'?\n\n### Problematic code:\n\n```sh\nalias server_uptime='ssh $host 'uptime -p''\n```\n\n### Correct code:\n\n```sh\nalias server_uptime='ssh $host '\"'uptime -p'\"\n```\n\n### Rationale:\n\nIn the first case, the user has four single quotes on a line, wishfully hoping that the shell will match them up as outer quotes around a string with literal single quotes:\n\n```sh\n#                   v--------match--------v\nalias server_uptime='ssh $host 'uptime -p''\n#                              ^--match--^\n```\n\nThe shell, meanwhile, always terminates single quoted strings at the first possible single quote:\n\n```sh\n#                   v---match--v\nalias server_uptime='ssh $host 'uptime -p''\n#                                        ^^\n```\n\nWhich is the same thing as `alias server_uptime='ssh $host uptime' -p`.\n\nThere is no way to nest single quotes. However, single quotes can be placed literally in double quotes, so we can instead concatenate a single quoted string and a double quoted string:\n\n```sh\n#                   v--match---v\nalias server_uptime='ssh $host '\"'uptime -p'\"\n#                               ^---match---^\n```\n\nThis results in an alias with embedded single quotes.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2027": {
    "remediation_points": 50000,
    "content": {
      "body": "## The surrounding quotes actually unquote this. Remove or escape them.\n\n### Problematic code:\n\n```sh\necho \"You enter \"$HOSTNAME\". You can smell the wumpus.\" >> /etc/issue\n```\n\n### Correct code:\n\n```sh\necho \"You enter $HOSTNAME. You can smell the wumpus.\" >> /etc/issue\n```\n\n### Rationale:\n\nAlways quoting variables and command expansions is good practice, but blindly putting quotes left and right of them is not.\n\nIn this case, ShellCheck has noticed that the quotes around the expansion are unquoting it, because the left quote is terminating an existing double quoted string, while the right quote starts a new one:\n\n```sh\necho \"You enter \"$HOSTNAME\". You can smell the wumpus.\"\n     |----------|         |---------------------------|\n        Quoted   No quotes           Quoted\n```\n\nIf the quotes were supposed to be literal, they should be escaped. If the quotes were supposed to quote an expansion (as in the example), they should be removed because this is already a double quoted string.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2028": {
    "remediation_points": 50000,
    "content": {
      "body": "# echo won't expand escape sequences. Consider printf.\n\n### Problematic code:\n\n```sh\necho \"Name:\\t$value\"\n```\n\n### Correct code:\n\n```sh\nprintf \"Name:\\t%s\\n\" \"$value\"\n```\n\n### Rationale:\n\nBackslash escapes like `\\t` and `\\n` are not expanded by echo, and become literal backslash-t, backslash-n.\n\n`printf` does expand these sequences, and should be used instead.\n\nOther, non-portable methods include `echo -e '\\t'` and `echo $'\\t'`. ShellCheck will warn if this is used in a script with shebang `#!/bin/sh`.\n\nIf you actually wanted a literal backslash-t, use\n\n```sh\necho \"\\\\t\"\n```\n\n### Exceptions\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2029": {
    "remediation_points": 50000,
    "content": {
      "body": "## Note that, unescaped, this expands on the client side.\n\n### Problematic code:\n\n```sh\nssh host \"echo $HOSTNAME\"\n```\n\n### Correct code:\n\n```sh\nssh host \"echo \\$HOSTNAME\"\n```\n\nor\n\n```sh\nssh host 'echo $HOSTNAME'\n```\n\n### Rationale:\n\nBash expands all arguments that are not escaped/singlequoted. This means that the problematic code is identical to\n\n```sh\nssh host \"echo clienthostname\"\n```\n\nand will print out the client's hostname, not the server's hostname.\n\nBy escaping the `$` in `$HOSTNAME`, it will be transmitted literally and evaluated on the server instead.\n\n### Exceptions\n\nIf you do want your string expanded on the client side, you can safely ignore this message.\n\nKeep in mind that the expanded string will be evaluated again on the server side, so for arbitrary variables and command output, you may need to add a layer of escaping with e.g. `printf %q`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2030": {
    "remediation_points": 50000,
    "content": {
      "body": "# Modification of var is local (to subshell caused by pipeline).\n\nSee companion warning [[SC2031]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2031": {
    "remediation_points": 50000,
    "content": {
      "body": "# var was modified in a subshell. That change might be lost.\n\n### Problematic code:\n\nThere are many ways of accidentally creating subshells, but a common one is piping to a loop:\n\n```bash\nn=0\nprintf \"%s\\n\" {1..10} | while read i; do (( n+=i )); done\necho $n\n```\n\n### Correct code:\n\n```bash\n# Bash specific: process substitution. Also try shopts like lastpipe.\nn=0\nwhile read i; do (( n+=i )); done < <(printf \"%s\\n\" {1..10})\necho $n\n```\n\nIn `sh`, a temp file (better if fifo or fd) can be used instead of process substitution. And if it's acceptable to do it with waiting, try Here Documents.\n\n### Rationale:\n\nVariables set in subshells are not available outside the subshell. This is a wide topic, and better described on the [Wooledge Bash Wiki](http://mywiki.wooledge.org/BashFAQ/024).\n\nHere are some constructs that cause subshells (shellcheck may not warn about all of them). In each case, you can replace `subshell1` by a command or function that sets a variable, e.g. simply `var=foo`, and the variable will appear to be unset after the command is run. Similarly, you can replace `regular` with `var=foo`, and it will be set afterwards:\n\nPipelines:\n\n```sh\nsubshell1 | subshell2 | subshell3    # Bash, Dash, Ash\nsubshell1 | subshell2 | regular      # Ksh, Zsh\n```\n\nCommand substitution:\n\n```sh\nregular \"$(subshell1)\" \"`subshell2`\"\n```\n\nProcess substitution:\n\n```sh\nregular <(subshell1) >(subshell2)\n```\n\nSome forms of grouping:\n\n```sh\n( subshell )\n{ regular; }\n```\n\nBackgrounding:\n\n```sh\nsubshell1 &\nsubshell2 &\n```\n\nAnything executed by external processes:\n\n```sh\nfind . -exec subshell1 {} \\;\nfind . -print0 | xargs -0 subshell2\nsudo subshell3\nsu -c subshell4\n```\n\nThis applies not only to setting variables, but also setting shell options and changing directories.\n\n### Exceptions\n\nYou can ignore this error if you don't care that the changes aren't reflected, because work on the value branches and shouldn't be recombined.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2032": {
    "remediation_points": 50000,
    "content": {
      "body": "# Use own script or sh -c '..' to run this from su.\n\nSee [[SC2033]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2033": {
    "remediation_points": 50000,
    "content": {
      "body": "# Shell functions can't be passed to external commands.\n\n### Problematic code:\n\n```sh\nfoo() { bar --baz \"$@\"; frob --baz \"$@\"; };\nfind . -exec foo {} +\n```\n\n### Correct code:\n\n```sh\nfind . -exec sh -c 'bar --baz \"$@\"; frob --baz \"$@\";' -- {} +\n```\n\n### Rationale:\n\nShell functions are only known to the shell. External commands like `find`, `xargs`, `su` and `sudo` do not recognize shell functions.\n\nInstead, the function contents can be executed in a shell, either through `sh -c` or by creating a separate shell script as an executable file.\n\n### Exceptions\n\nIf you're intentionally passing a word that happens to have the same name as a declared function, you can quote it to make shellcheck ignore it, e.g.\n\n```sh\nnobody() {\n  sudo -u \"nobody\" \"$@\"\n}\n\n```\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2034": {
    "remediation_points": 50000,
    "content": {
      "body": "# foo appears unused. Verify it or export it.\n\n### Problematic code:\n\n```sh\nfoo=42\necho \"$FOO\"\n```\n\n### Correct code:\n\n```sh\nfoo=42\necho \"$foo\"\n```\n\n### Rationale:\n\nVariables not used for anything are often associated with bugs, so ShellCheck warns about them.\n\nAlso note that something like `local let foo=42` does not make a `let` statement local -- it instead declares an additional local variable named `let`.\n\n### Exceptions\n\nShellCheck may not always realize that the variable is in use (especially with indirection), and may not realize you don't care (with throwaway variables or unimplemented features).\n\nFor throwaway variables, consider using `_` as a dummy:\n\n```sh\nread _ last _ zip _ _ <<< \"$str\"\necho \"$last, $zip\"\n```\n\nor use a directive to disable the warning:\n\n```sh\n# shellcheck disable=SC2034\nread first last email zip lat lng <<< \"$str\"\necho \"$last, $zip\"\n```\n\nFor indirection, there's not much you can do without rewriting to use arrays or similar:\n\n```sh\nbar=42  # will always appear unused\nfoo=bar\necho \"${!foo}\"\n```\n\nThis is expected behavior, and not a bug. There is no good way to statically analyze indirection in shell scripts, just like static C analyzers have a hard time preventing segfaults.\n\nAs always, there are ways to [[ignore]] this and other messages if they frequently get in your way.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2035": {
    "remediation_points": 50000,
    "content": {
      "body": "# Use ./\\*glob* or -- \\*glob* so names with dashes won't become options.\n\n### Problematic code:\n    rm *\n\n### Correct code:\n\n    rm ./*\n\nor\n\n    rm -- *\n\n### Rationale\n\nSince files and arguments are strings passed the same way, programs can't properly determine which is which, and rely on dashes to determine what's what.\n\nA file named `-f` (`touch -- -f`) will not be deleted by the problematic code. It will instead be interpreted as a command line option, and `rm` will even report success.\n\nUsing `./*` will instead cause the glob to be expanded into `./-f`, which no program will treat as an option.\n\nSimilarly, `--` by convention indicates the end of options, and nothing after it will be treated like flags.\n\nFor more information, see \"[Filenames and Pathnames in Shell: How to do it Correctly](http://www.dwheeler.com/essays/filenames-in-shell.html)\".\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2036": {
    "remediation_points": 50000,
    "content": {
      "body": "## If you wanted to assign the output of the pipeline, use a=$(b | c) .\n\n### Problematic code:\n\n```sh\nsum=find | wc -l\n```\n\n### Correct code:\n\n```sh\nsum=$(find | wc -l)\n```\n\n### Rationale:\n\nThe intention in this code was that `sum` would in some way get the value of the command `find | wc -l`.\n\nHowever, `|` has precedence over the `=`, so the command is a two stage pipeline consisting of `sum=find` and `wc -l`.\n\n`sum=find` is a plain string assignment. Since it happens by itself in an independent pipeline stage, it has no effect: it produces no output, and the variable disappears when the pipeline stage finishes. Because the assignment produces no output, `wc -l` will count 0 lines.\n\nTo instead actually assign a variable with the output of a command, command substitution `$(..)` can be used.\n\n### Exceptions:\n\nNone. This warning is triggered whenever the first stage of a pipeline is a single assignment, which is never correct.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2038": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use -print0/-0 or find -exec + to allow for non-alphanumeric filenames.\n\n### Problematic code:\n\n```sh\nfind . -type f | xargs md5sum\n```\n\n### Correct code:\n\n```sh\nfind . -type f -print0 | xargs -0 md5sum\n```\n\n### Rationale:\n\nBy default, `xargs` interprets spaces and quotes in an unsafe and unexpected way. Whenever it's used, it should be used with `-0` or `--null` to split on `\\0` bytes, and `find` should be made to output `\\0` separated filenames.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2039": {
    "remediation_points": 50000,
    "content": {
      "body": "## In POSIX sh, *something* is undefined.\nYou have declared that your script works with `/bin/sh`, but you are using features that have undefined behavior according to the POSIX specification. \n\nIt may currently work for you, but it can or will fail on other OS, the same OS with different configurations, from different contexts (like initramfs/chroot), or in different versions of the same OS, including future updates to your current system.\n\nEither declare that your script requires a specific shell like `#!/bin/bash` or `#!/bin/dash`, or rewrite the script in a portable way.\n\nFor help with rewrites, the Ubuntu wiki has [a list of portability issues](https://wiki.ubuntu.com/DashAsBinSh) that broke people's `#!/bin/sh` scripts when Ubuntu switched from Bash to Dash. ShellCheck may not warn about all these issues.\n\n### `$'c-style-escapes'`\n\nbash, ksh:\n\n```Bash\na=$' \\t\\n'\n```\n\nPOSIX:\n\n```sh\na=\"$(printf '%b_' ' \\t\\n')\"; a=\"${a%_}\" # protect trailing \\n\n```\n\nWant some good news? See http://austingroupbugs.net/view.php?id=249#c590.\n\n### `$\"msgid\"`\n\nBash:\n\n```Bash\necho $\"foo $(bar) baz\"\n```\n\nPOSIX:\n\n```sh\n. gettext.sh # GNU Gettext sh library\n# ...\nbarout=$(bar)\neval_gettext 'foo $barout baz' # See GNU Gettext doc for more info.\n```\n\nOr you can change them to normal double quotes so you go without `gettext`.\n\n### Arithmetic `for` loops\n\nBash:\n\n```Bash\nfor ((init; test; next)); do foo; done\n```\n\nPOSIX:\n\n```sh\n: $((init))\nwhile [ $((test)) -ne 0 ]; do foo; : $((next)); done\n```\n\n### standalone `((..))`\n\nBash:\n\n```Bash\n((a=c+d))\n((d)) && echo d is true.\n```\n\nPOSIX:\n\n```sh\n: $((a=c+d)) # discard the output of the arith expn with `:` command\n[ $((d)) -ne 0 ] && echo d is true. # manually check non-zero => true\n```\n\n### `select` loops\n\nIt takes extra care over terminal columns to make select loop look like bash's, which generates a list with multiple items on one line, or like `ls`.\n\nIt is, however, still possible to make a naive translation for `select foo in bar baz; do eat; done`:\n\n```sh\nwhile\n  _i=0 _foo= foo=\n  for _name in bar baz; do echo \"$((_i+=1))) $_name\"; done\n  printf '$# '; read _foo\ndo\n  case _foo in 1) foo=bar;; 2) foo=baz;; *) continue;; esac\n  eat\ndone\n```\n\n### Here-strings\n\nBash, ksh:\n\n```Bash\ngrep aaa <<< \"$g\"\n```\n\nPOSIX:\n\n```sh\nprintf '%s' \"$g\" | grep aaa # since we want to avoid `echo`\n```\n\n### echo flags\n\nSee https://unix.stackexchange.com/tags/echo/info.\n\n### `${var/pat/replacement}`\n\nBash:\n\n```Bash\necho \"${TERM/%-256*}\"\n```\n\nPOSIX:\n\n```sh\necho \"$TERM\" | sed -e 's/-256.*$//g'\n# Special case for this since we are matching the end:\necho \"${TERM%-256*}\"\n```\n\n### `printf %q`\n\nBash:\n\n```Bash\nprintf '%q ' \"$@\"\n```\n\nPOSIX:\n\n```sh\n# TODO: Interpret it back to printf escapes for hard-to-copy chars like \\t?\n# See also: http://git.savannah.gnu.org/cgit/libtool.git/tree/gl/build-aux/funclib.sh?id=c60e054#n1029\nreuse_quote()(\n  for i; do echo -n \\'; echo -n \"$i\" | sed -e \"s/'/'\\\\\\\\''/g\"; echo -n \"' \"; done\n)\nreuse_quote \"$@\"\n```\n\n## Exception\n\nDepends on what your expected POSIX shell providers would use.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2040": {
    "remediation_points": 50000,
    "content": {
      "body": "## #!/bin/sh was specified, so ____ is not supported, even when sh is actually bash.\n\nThe shebang indicates that the script works with `/bin/sh`, but you are using non-standard features that may not work with `/bin/sh`, **even if /bin/sh is actually bash**. Bash behaves differently when invoked as `sh`, and disabling support for the highlighted feature is one part of that.\n\nSpecify `#!/usr/bin/env bash` to ensure that bash (or your shell of choice) will be used, or rewrite the script to be more portable.\n\nThe Ubuntu wiki has [a list of portability issues](https://wiki.ubuntu.com/DashAsBinSh) and suggestions on how to rewrite them.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2041": {
    "remediation_points": 50000,
    "content": {
      "body": "## This is a literal string. To run as a command, use $(seq 1 10)\n\n### Problematic code:\n\n```sh\nfor i in 'seq 1 10'\ndo\n  echo \"$i\"\ndone\n```\n\n### Correct code:\n\n```sh\nfor i in $(seq 1 10)\ndo\n  echo \"$i\"\ndone\n```\n\n### Rationale:\n\nThe intent was to run the code in the single quotes. This would have worked with slanted backticks, `` `..` ``, but here the very similar looking single quotes `'..'` were used, resulting in a string literal instead of command output.\n\nThis is one of the many problems with backticks, so it's better to use `$(..)` to expand commands.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2043": {
    "remediation_points": 50000,
    "content": {
      "body": "## This loop will only run once, with var=value\n\n### Problematic code:\n\n```sh\nfor var in value\ndo\n  echo \"$var\"\ndone\n```\n\n### Correct code:\n\nCorrect code depends on what you want to do.\n\nTo iterate over files in a directory, instead of `for var in /my/dir` use:\n\n```sh\nfor var in /my/dir/* ; do echo \"$var\"; done\n```\n\nTo iterate over lines in a file or command output, use a while read loop instead:\n\n```sh\nmycommand | while IFS= read -r line; do echo \"$line\"; done\n```\n\nTo iterate over *words* written to a command or function's stdout, instead of `for var in myfunction`, use\n\n```sh\nfor var in $(myfunction); do echo \"$var\"; done\n```\n\nTo iterate over *words* in a variable, instead of  `for var in myvariable`, use\n\n```sh\nfor var in $myvariable; do echo \"$var\"; done\n```\n\n\n\n### Rationale:\n\nShellCheck has detected that your for loop iterates over a single, constant value. This is most likely a bug in your code, caused by you not expanding the value in the way you want.\n\nYou should make sure that whatever you loop over will expand into multiple words.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2044": {
    "remediation_points": 50000,
    "content": {
      "body": "## For loops over find output are fragile. Use find -exec or a while read loop.\n\n### Problematic code:\n\n```sh\nfor file in $(find mydir -mtime -7 -name '*.mp3')\ndo\n  let count++\n  echo \"Playing file no. $count\"\n  play \"$file\"\ndone\necho \"Played $count files\"\n```\n\nThis will fail for filenames containing spaces and similar, such as `My File.mp3`, and has a series of potential globbing issues depending on other filenames in the directory like (if you have `MyFile2.mp3` and `MyFile[2014].mp3`, the former file will play twice and the latter will not play at all).\n\n### Correct code:\n\nThere are many possible fixes, each with its pros and cons.\n\nThe most general fix (that requires the least amount of thinking to apply) is having `find` output a `\\0` separated list of files and consuming them in a `while read` loop:\n\n```sh\nwhile IFS= read -r -d '' file\ndo\n  let count++\n  echo \"Playing file no. $count\"\n  play \"$file\"\ndone <   <(find mydir -mtime -7 -name '*.mp3' -print0)\necho \"Played $count files\"\n```\n\nIn usage it's very similar to the `for` loop: it gets its output from a `find` statement, it executes a shell script body, it allows updating/aggregating variables, and the variables are available when the loop ends.\n\nIt requires Bash, and works with GNU, Busybox, OS X, FreeBSD and OpenBSD find, but not POSIX find.\n\n##### If `find` is just matching globs recursively\n\nIf you don't need `find` logic like `-mtime -7` and just use it to match globs recursively (all `*.mp3` files under a directory), you can instead use `globstar` and `nullglob` instead of `find`, and still use a `for` loop:\n\n```sh\nshopt -s globstar nullglob\nfor file in mydir/**/*.mp3\ndo\n  let count++\n  echo \"Playing file no. $count\"\n  play \"$file\"\ndone\necho \"Played $count files\"\n```\n\nThis is bash 4 specific.\n\n\n##### For POSIX\n\nIf you need POSIX compliance, this is a fair approach:\n\n```sh\nfind mydir ! -name \"$(printf \"*\\n*\")\" -name '*.mp3' > tmp\nwhile IFS= read -r file\ndo\n  let count++\n  echo \"Playing file #$count\"\n  play \"$file\"\ndone < tmp\nrm tmp\necho \"Played $count files\"\n```\n\nThe only problem is for filenames containing line feeds. A `! -name \"$(printf \"*\\n*\")\"` has been added to simply skip these files, just in case there are any.\n\nIf you don't need variables to be available after the loop (here, if you don't need to print the final play count at the end), you can skip the `tmp` file and just pipe from `find` to `while`.\n\n##### For simple commands with no aggregation\n\nIf you don't need a shell script loop body or any form of variable  like if we only wanted to play the file, we can dramatically simplify while maintaining POSIX compatibility:\n\n```sh\n# Simple and POSIX\nfind mydir -name '*.mp3' -exec play {} \\;\n```\n\nThis does not allow things like `let counter++` because `let` is a shell builtin, not an external command.\n\n##### For shell commands with no aggregation\n\nIf we do need a shell script body but no aggregation, you can do the above but invoking `sh` (this is still POSIX):\n\n```sh\nfind mydir -name '*.mp3' -exec sh -c '\n    echo \"Playing ${1%.mp3}\"\n    play \"$1\"\n  ' sh {} \\;\n```\n\nThis would not be possible without `sh`, because `${1%.mp3}` is a shell construct that `find` can't evaluate by itself. If we had tried to `let counter++` in this loop, we would have found that the value never changes.\n\nNote that using `+` instead of `\\;`, and using an embedded `for file in \"$@\"` loop rather than `\"$1\"`, will not allow aggregating variables. This is because for large lists, `find` will invoke the command multiple times, each time with some chunk of the input.\n\n\n### Rationale:\n\n`for var in $(find ...)`  loops rely on word splitting and will evaluate globs, which will wreck havoc with filenames containing whitespace or glob characters.\n\n`find -exec` `for i in glob` and `find`+`while` do not rely on word splitting, so they avoid this problem.\n\n### Exceptions\n\nIf you know about and carefully apply `IFS=$'\\n'` and `set -f`, you could choose to ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2045": {
    "remediation_points": 50000,
    "content": {
      "body": "## Iterating over ls output is fragile. Use globs.\n\n### Problematic code:\n\n    for f in $(ls *.wav)\n    do\n      echo \"$f\"\n    done\n\n### Correct code:\n\n    for f in *.wav\n    do\n      [[ -e $f ]] || break  # handle the case of no *.wav files\n      echo \"$f\"\n    done\n\nAlso note that in Bash, `shopt -s nullglob` will allow the loop to run 0 times instead of 1 if there are no matches. There are also [several other conditions](http://mywiki.wooledge.org/BashPitfalls#for_i_in_.24.28ls_.2A.mp3.29) to be aware of.\n\n### Rationale:\n\nWhen looping over a set of files, it's always better to use globs when possible. Using command expansion causes word splitting and glob expansion, which will cause problems for certain filenames (typically first seen when trying to process a file with spaces in the name).\n\nThe following files can or will break the first loop:\n\n    touch 'filename with spaces.wav'\n    touch 'filename with * globs.wav'\n    touch 'More_Globs[2003].wav'\n    touch 'files_with_fønny_chæracters_in_certain_locales.wav'\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2046": {
    "remediation_points": 50000,
    "content": {
      "body": "# Quote this to prevent word splitting\n\n### Problematic code:\n\n    ls -l $(getfilename)\n\n### Correct code:\n\n    # getfilename outputs 1 file\n    ls -l \"$(getfilename)\"\n\n    # getfilename outputs multiple files, linefeed separated\n    getfilename | while IFS='' read -r line\n    do\n      ls -l \"$line\"\n    done\n\n### Rationale:\n\nWhen command expansions are unquoted, word splitting and globbing will occur. This often manifests itself by breaking when filenames contain spaces.\n\nTrying to fix it by adding quotes or escapes to the data will not work. Instead, quote the command substitution itself.\n\nIf the command substitution outputs multiple pieces of data, use a loop instead.\n\n### Exceptions\n\nIn rare cases you actually want word splitting, such as in\n\n    gcc $(pkg-config --libs openssl) client.c\n\nThis is because `pkg-config` outputs `-lssl -lcrypto`, which you want to break up by spaces into `-lssl` and `-lcrypto`.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2048": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use \"$@\" (with quotes) to prevent whitespace problems.\n\n### Problematic code:\n\n```sh\ncp $* ~/dir\n```\n\n### Correct code:\n\n```sh\ncp \"$@\" ~/dir\n```\n\n### Rationale:\n\n`$*`, unquoted, is subject to word splitting and globbing.\n\nLet's say you have three arguments: `baz`, `foo bar` and `*`\n\n`\"$@\"` will expand into exactly that: `baz`, `foo bar` and `*`\n\n`$*` will expand into multiple other arguments: `baz`, `foo`, `bar`, `file.txt` and `otherfile.jpg`\n\nSince the latter is rarely expected or desired, ShellCheck warns about it.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2051": {
    "remediation_points": 50000,
    "content": {
      "body": "## Bash doesn't support variables in brace range expansions.\r\n\r\n### Problematic code:\r\n\r\nfor i in {1..$n}\r\ndo\r\n  echo \"$i\"\r\ndone\r\n\r\n### Correct code:\r\n\r\nfor ((i=0; i<n; i++))\r\ndo\r\n  echo \"$i\"\r\ndone\r\n\r\n### Rationale:\r\n\r\nIn Bash, brace expansion happens before variable expansion. This means that brace expansion will not account for variables.\r\n\r\nFor integers, use an arithmetic for loop instead. For zero-padded numbers or letters, use of eval may be warranted:\r\n\r\nfrom=\"a\" to=\"m\"\r\nfor c in $(eval \"echo {$from..$to}\"); do echo \"$c\"; done\r\n\r\nor more carefully (if `from`/`to` could be user input, or if the brace expansion could have spaces):\r\n\r\nfrom=\"a\" to=\"m\"\r\nwhile IFS= read -d '' -r c\r\ndo\r\n  echo \"Read $c\"\r\ndone <  <(eval \"printf '%s\\0' $(printf \"{%q..%q}.jpg\" \"$from\" \"$to\")\")\r\n\r\n\r\n### Exceptions\r\n\r\nNone (if you're writing for e.g. zsh, make sure the shebang indicates this so shellcheck won't warn)\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2055": {
    "remediation_points": 50000,
    "content": {
      "body": "## You probably wanted && here\n\n### Problematic code:\n\n```sh\nif [[ $1 != foo || $1 != bar ]]\nthen\n  echo \"$1 is not foo or bar\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [[ $1 != foo && $1 != bar ]]\nthen\n  echo \"$1 is not foo or bar\"\nfi\n```\n\n### Rationale:\n\nThis is not a bash issue, but a simple, common logical mistake applicable to all languages.\n\n`[[ $1 != foo || $1 != bar ]]` is always true:\n\n* If `$1 = foo` then `$1 != bar` is true, so the statement is true.\n* If `$1 = bar` then `$1 != foo` is true, so the statement is true.\n* If `$1 = cow` then `$1 != foo` is true, so the statement is true.\n\n`[[ $1 != foo && $1 != bar ]]` matches when `$1` is not `foo` and not `bar`:\n\n* If `$1 = foo`, then `$1 != foo` is false, so the statement is false.\n* If `$1 = bar`, then `$1 != bar` is false, so the statement is false.\n* If `$1 = cow`, then both `$1 != foo` and `$1  != bar` is true, so the statement is true.\n\nThis statement is identical to `! [[ $1 = foo || $1 = bar ]]`, which also works correctly.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2059": {
    "remediation_points": 50000,
    "content": {
      "body": "# Don't use variables in the printf format string. Use printf \"..%s..\" \"$foo\".\n\n### Problematic code:\n\n```sh\nprintf \"Hello, $NAME\\n\"\n```\n\n### Correct code:\n\n```sh\nprintf \"Hello, %s\\n\" \"$NAME\"\n```\n\n### Rationale:\n\n`printf` interprets escape sequences and format specifiers in the format string. If variables are included, any escape sequences or format specifiers in the data will be interpreted too, when you most likely wanted to treat it as data. Example:\n\n```sh\ncoverage='96%'\nprintf \"Unit test coverage: %s\\n\" \"$coverage\"\nprintf \"Unit test coverage: $coverage\\n\"\n```\n\nThe first printf writes `Unit test coverage: 96%`.\n\nThe second writes ``bash: printf: `\\': invalid format character``\n\n### Exceptions\n\nSometimes you may actually want to interpret data as a format string, like in:\n\n```sh\nhexToAscii() { printf \"\\x$1\"; }\nhexToAscii 21\n```\n\nLike all warnings, you can selectively silence this warning with a [directive](Directive).\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2060": {
    "remediation_points": 50000,
    "content": {
      "body": "# Quote parameters to tr to prevent glob expansion.\n\n### Problematic code:\n\n```sh\ntr -cd [:digit:]\n```\n\n### Correct code:\n\n```sh\ntr -cd '[:digit:]'\n```\n\n### Rationale:\n\n`[:digit:]` is a shell glob that matches any single character file named e.g. `g` or `t` in the current directory. Quoting it prevents the script from breaking in directories with files like this.\n\n### Exceptions\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2061": {
    "remediation_points": 50000,
    "content": {
      "body": "## Quote the parameter to -name so the shell won't interpret it.\n\n### Problematic code:\n\n```sh\nfind . -name *.txt\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.txt'\n```\n### Rationale:\n\nSeveral find options take patterns to match against, including `-ilname`, `-iname`, `-ipath`, `-iregex`, `-iwholename`, `-lname`, `-name`, `-path`, `-regex` and `-wholename`.\n\nThese compete with the shell's pattern expansion, and must therefore be quoted so that they are passed literally to `find`.\n\nThe example command may end up executing as `find . -name README.txt` after the shell has replaced the `*.txt` with a matching file `README.txt` from the current directory. \n\nThis may happen today or suddenly in the future.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2062": {
    "remediation_points": 50000,
    "content": {
      "body": "# Quote the grep pattern so the shell won't interpret it.\n\n### Problematic code\n    grep foo* file\n\n### Correct code\n    grep \"foo*\" file\n\n### Rationale\nThe regex passed to grep frequently contains characters that collide with globs. The code above is supposed to match \"f followed by 1 or more o's\", but if the directory contains a file called \"foo.txt\", an unquoted pattern will cause it to become `grep foo.txt file`.\n\nTo prevent this, always quote the regex passed to grep, especially when it contains one or more glob character.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2063": {
    "remediation_points": 50000,
    "content": {
      "body": "# Grep uses regex, but this looks like a glob.\n\n### Problematic code:\n\n```sh\ngrep '*foo*'\n```\n\n### Correct code:\n\n```sh\ngrep 'foo'   # or more explicitly,  grep '.*foo.*'\n```\n\n### Rationale:\n\nIn globs, `*` matches any number of any character.\n\nIn regex, `*` matches any number of the preceding character.\n\n`grep` uses regex, not globs, so this means that `grep '*foo'` is nonsensical because there's no preceding character for `*`.\n\nIf the intention was to match \"any number of characters followed by foo\", use `'.*foo'`. Also note that since grep matches substrings, this will match \"fishfood\". Use anchors to prevent this, e.g. `foo$`.\n\nThis also means that `f*` will match \"hello\", because `f*` matches 0 (or more) \"f\"s and there are indeed 0 \"f\" characters in \"hello\". Again, use `grep 'f'` to find strings containing \"f\", or `grep '^f'` to find strings starting with \"f\".\n\n\n### Exceptions\n\nIf you're aware of the differences between globs and regex, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2064": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use single quotes, otherwise this expands now rather than when signalled.\n\n### Problematic code:\n\n```sh\ntrap \"echo \\\"Finished on $(date)\\\"\" EXIT\n```\n\n### Correct code:\n\n```sh\ntrap 'echo \"Finished on $(date)\"' EXIT\n```\n\n### Rationale:\n\nWith double quotes, all parameter and command expansions will expand when the trap is defined rather than when it's executed.\n\nIn the example, the message will contain the date on which the trap was declared, and not the date on which the script exits.\n\nUsing single quotes will prevent expansion at declaration time, and save it for execution time.\n\n### Exceptions\n\nIf you don't care that the trap code is expanded early because the commands/variables won't change during execution of the script, or because you want to use the current and not the future values, then you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2065": {
    "remediation_points": 50000,
    "content": {
      "body": "## This is interpreted as a shell file redirection, not a comparison.\n\n### Problematic code:\n\n```sh\n[ 1 >2 ] || [ 3>'aaa bb' ] # Simple example of problematic code\n```\n\n### Correct code:\n\n```sh\n[ 1 -gt 2 ] || [ 3 \\> 'aaa bb' ] # arithmetical, lexicographical\n```\n### Rationale:\n\nA word that looks like a redirection in simple shell commands causes it to be interpreted as a redirection.\nShellCheck would guess that you don't want it in tests.\n\n### Exceptions:\n\nWhen it's among a continuous list of redirections at the end of a simple `test` command, it's more likely that\nthe user really meant to do a redirection. Or any other case that you mean to do that.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2066": {
    "remediation_points": 50000,
    "content": {
      "body": "## Since you double quoted this, it will not word split, and the loop will only run once.\n\n### Problematic code:\n\n```sh\nfor s in \"$(mycommand)\"; do echo \"$s\"; done\n```\n\n### Correct code:\n\nThe correct code depends on your intention. Let's say you're in a directory with the files `file.png` and `My cat.png`, and you want to loop over a command that outputs (or variable that contains):\n\n```sh\nhello world\nMy *.png\n```\n\n#### Loop over each line without globbing (`hello world`, `My *.png`)\n\n```sh\nmycommand | while IFS= read -r s; do echo \"$s\"; done\n```\n\n#### Loop over each word with globbing (`hello`, `world`, `My`, `file.png`, `My cat.png`):\n\n```sh\n# relies on the fact that IFS by default contains space-tab-linefeed\nfor s in $(mycommand); do echo \"$s\"; done\n```\n\n#### Loop over each line with globbing (`hello world`, `My cat.png`)\n\n```sh\n# explicitly set IFS to contain only a line feed\nIFS='\n'\nfor s in $(mycommand); do echo \"$s\"; done\n```\n\n### Rationale:\n\nYou get this warning because you have a loop that will only ever run exactly one iteration. Since you have a loop, you clearly expect it to run more than once. You just have to decide how it should be split up.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2067": {
    "remediation_points": 50000,
    "content": {
      "body": "## Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument.\n\n### Problematic code:\n\n```sh\nfind . -type f -exec shellcheck {} | wc -l \\;\nfind . -exec echo {} ;\n```\n\n### Correct code:\n\n```sh\nfind . -type f -exec sh -c 'shellcheck \"$1\" | wc -l' -- {} \\;\nfind . -exec echo {} \\;\n```\n\n### Rationale:\n\n`find -exec` is still subject to all normal shell rules, so all shell features like `|`, `||`, `&` and `&&` will apply to the `find` command itself, and not to the command you are trying to construct with `-exec`.\n\n`find . -exec foo {} && bar {} \\;` means run the command `find . -exec foo {}`, and if find is successful, run the command `bar \"{}\" \";\"`.\n\nTo instead go through each file and run `foo file && bar file` on it, invoke a shell that can interpret `&&`:\n\n```sh\nfind . -exec sh 'foo \"$1\" && bar \"$1\"' -- {} \\;\n```\n\nYou can also use find `-a` instead of shell `&&`:\n\n```sh\nfind . -exec foo {} \\; -a -exec bar {} \\;\n```\n\nThis will have the same effect (`-a` is also the default when two commands are specified, and can therefore be omitted).\n\n### Exceptions\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2068": {
    "remediation_points": 50000,
    "content": {
      "body": "## Double quote array expansions to avoid re-splitting elements.\n\n### Problematic code:\n\n```sh\ncp $@ ~/dir\n```\n\n### Correct code:\n\n```sh\ncp \"$@\" ~/dir\n```\n\n### Rationale:\n\nDouble quotes around `$@` (and similarly, `${array[@]}`) prevents globbing and word splitting of individual elements, while still expanding to multiple separate arguments.\n\nLet's say you have three arguments: `baz`, `foo bar` and `*`\n\n`\"$@\"` will expand into exactly that: `baz`, `foo bar` and `*`\n\n`$@` will expand into multiple other arguments: `baz`, `foo`, `bar`, `file.txt` and `otherfile.jpg`\n\nSince the latter is rarely expected or desired, ShellCheck warns about it.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2069": {
    "remediation_points": 50000,
    "content": {
      "body": "## The order of the 2>&1 and the redirect matters. The 2>&1 has to be last.\n\n### Problematic code:\n\n```sh\nfirefox 2>&1 > /dev/null\n```\n\n### Correct code:\n\n```sh\nfirefox > /dev/null 2>&1\n```\n\n### Rationale:\n\nRedirections are handled in order.\n\nThe problematic code means \"Point stderr to where stdout is currently pointing (the terminal). Then point stdout to /dev/null\".\n\nThe correct code means \"Point stdout to /dev/null. Then point stderr to where stdout is currently pointing (/dev/null)\".\n\nIn other words, the problematic code hides stdout and shows stderr. The correct code hides both stderr and stdout, which is usually the intention.\n\n### Exceptions\n\nIf you want stderr as stdout and stdout to a file, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2070": {
    "remediation_points": 50000,
    "content": {
      "body": "## -n doesn't work with unquoted arguments. Quote or use [\\[ ]].\n\n### Problematic code:\n\n```sh\nif [ -n $var ]\nthen\n  echo \"var has a value\"\nelse\n  echo \"var is empty\"\nfi\n```\n\n### Correct code:\n\nIn POSIX:\n\n```sh\nif [ -n \"$var\" ]\nthen\n  echo \"var has a value\"\nelse\n  echo \"var is empty\"\nfi\n```\n\nIn bash/ksh:\n\n```sh\nif [[ -n $var ]]\nthen\n  echo \"var has a value\"\nelse\n  echo \"var is empty\"\nfi\n```\n\n\n### Rationale:\n\nWhen `$var` is unquoted, a blank value will cause it to wordsplit and disappear. If `$var` is empty, these two statements are identical:\n\n```sh\n[ -n $var ]\n[ -n ]\n```\n\n`[ string ]` is shorthand for testing if a string is empty. This is still true if `string` happens to be `-n`. `[ -n ]` is therefore true, and by extension so is `[ -n $var ]`.\n\nTo fix this, either quote the variable, or (if your shell supports it) use `[[ -n $var ]]` which generally has fewer caveats than `[`.\n\n### Exceptions:\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2071": {
    "remediation_points": 50000,
    "content": {
      "body": "## > is for string comparisons. Use -gt instead.\n\n### Problematic code:\n\n```sh\nif [[ $var > 10 ]]\nthen\n  echo \"Incorrectly triggers when var=5\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [[ $var -gt 10 ]]\nthen\n  echo \"Correct numerical comparison\"\nfi\n```\n### Rationale:\n\n`<` and `>`, in both `[[` and `[` (when escaped) will do a lexicographical comparison, not a numerical comparison. \n\nThis means that `[[ 5 > 10 ]]` is true because 5 comes after 10 alphabetically. Meanwhile `[[ 5 -gt 10 ]]` is false because 5 does not come after 10 numerically.\n\nIf you want to compare numbers by value, use the numerical comparison operators `-gt`, `-ge`, `-lt` and `-le`.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2072": {
    "remediation_points": 50000,
    "content": {
      "body": "## Decimals are not supported. Either use integers only, or use bc or awk to compare.\n\n### Problematic code:\n\n```sh\n[[ 2 -lt 3.14 ]]\n```\n\n### Correct code:\n\n```sh\n[[ 200 -lt 314 ]]                   # Use fixed point math\n[[ $(echo \"2 < 3.14\" | bc) == 1 ]]  # Use bc\n```\n\n### Rationale:\n\nBash and Posix sh does not support decimals in numbers. Decimals should either be avoided, or compared using a tool that does support them.\n\n### Exceptions\n\nIf the strings happen to be version numbers and you're using `<`, or `>` to compare them as strings, and you consider this an acceptable thing to do, then you can ignore this warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2076": {
    "remediation_points": 50000,
    "content": {
      "body": "## Don't quote rhs of =~, it'll match literally rather than as a regex.\n\n### Problematic code:\n\n```sh\n[[ $foo =~ \"^fo+bar$\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ $foo =~ ^fo+bar$ ]]\n```\n\n### Rationale:\n\nQuotes on the right hand side of `=~` can be used to match literally, so that `[[ $1 =~ ^\"$2\".* ]]` works even if `$2` contains regex metacharacters. This mirrors the behavior of globs, `[[ $1 = \"$2\"* ]]`.\n\nThis also means that the problematic code tries to match literal carets and plus signs instead of interpreting them as regular expression matchers.  To match as a regex, it must be unquoted.\n\n### Exceptions:\n\nIf you do want to match literally just to do a plain substring search, e.g. `[[ $foo =~ \"bar\" ]]`, you could ignore this message, but consider using a more canonical glob match instead: `[[ $foo = *\"bar\"* ]]`.\n\n### Compatibility:\n\n* In Bash 3.2 and newer with shopt `compat31` *disabled (the default)*, quoted patterns are literal whereas unquoted patterns are parsed for regex metacharacters.\n* In Bash 3.2 and newer with shopt `compat31` *enabled*, quoted and unquoted patterns match identically.\n* In Bash 3.1 quoted and unquoted patterns match identically.\n\nSee http://stackoverflow.com/questions/218156/bash-regex-with-quotes\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2077": {
    "remediation_points": 50000,
    "content": {
      "body": "## You need spaces around the comparison operator.\n\n### Problematic code:\n\n```sh\n[[ 0=1 ]]\n```\n\n### Correct code:\n\n```sh\n[[ 0 = 1 ]]\n```\n\n### Rationale:\n\n`[[ 0 = 1 ]]` means \"check if 0 and 1 are equal\".\n\n`[[ str ]]` is short form for `[[ -n str ]]`, and means \"check if `str` is non-empty\". It doesn't matter if `str` happens to contain `0=1`.\n\nAlways use spaces around the comparison operator in `[..]` and `[[..]]`, otherwise it won't be recognized as an operator.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2082": {
    "remediation_points": 50000,
    "content": {
      "body": "## To expand via indirection, use name=\"foo$n\"; echo \"${!name}\".\n\n### Problematic code:\n\n```sh\nvar_1=\"hello world\"\nn=1\necho \"${var_$n}\"\n```\n\n### Correct code:\n\nBash/ksh:\n\n```sh\n# Use arrays instead of dynamic names\ndeclare -a var\nvar[1]=\"hello world\"\nn=1\necho \"${var[n]}\"\n```\n\nor\n\n```sh\n# Expand variable names dynamically\nvar_1=\"hello world\"\nn=1\nname=\"var_$n\"\necho \"${!name}\"\n```\n\nPOSIX sh:\n\n```sh\n# Expand dynamically with eval\nvar_1=\"hello world\"\nn=1\neval \"tmp=\\$var_$n\"\necho \"${tmp}\"\n```\n\n### Rationale:\n\nYou can expand a variable `var_1` with `${var_1}`, but you can not generate the string `var_1` with an embedded expansion, like `${var_$n}`.\n\nInstead, if at all possible, you should use an array. Bash and ksh support both numerical and associative arrays, and an example is shown above.\n\nIf you can't use arrays, you can indirectly reference variables by creating a temporary variable with its name, e.g. `myvar=\"var_$n\"` and then expanding it indirectly with `${!myvar}`. This will give the contents of the variable `var_1`.\n\nIf using POSIX sh, where neither arrays nor `${!var}` is available, `eval` can be used. You must be careful in sanitizing the data used to construct the variable name to avoid arbitrary code execution.\n\n### Exceptions:\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2084": {
    "remediation_points": 50000,
    "content": {
      "body": "## Remove '$' or use '_=$((expr))' to avoid executing output.\n\n### Problematic code:\n\n```sh\ni=4\n$(( i++ ))\n```\n\n### Correct code:\n\nBash, Ksh:\n\n```sh\ni=4\n(( i++ ))\n```\n\nPOSIX (assuming `++` is supported):\n\n```sh\ni=4\n_=$(( i++ ))\n```\n\nAlternative POSIX version that does not preserve the exit code:\n\n```sh\n: $(( i++ ))\n```\n\n### Rationale:\n\n`$((..))` expands to a number. If it's the only word on the line, the shell will try to execute this number as a command name:\n\n```sh\n$ i=4\n$ $(( i++ ))\n4: command not found\n$ echo $i\n5\n```\n\nTo avoid trying to execute the number as a command name, use one of the methods mentioned:\n\n```sh\n$ i=4\n$ _=$(( i++ ))\n$ echo $i\n5\n```\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2086": {
    "remediation_points": 50000,
    "content": {
      "body": "#Double quote to prevent globbing and word splitting.\n\n### Problematic code:\n\n```sh\necho $1\nfor i in $*; do :; done # this one and the next one also applies to expanding arrays.\nfor i in $@; do :; done\n```\n\n### Correct code:\n\n```sh\necho \"$1\"\nfor i in \"$@\"; do :; done # or, 'for i; do'\n```\n### Rationale\n\nThe first code looks like \"print the first argument\". It's actually \"Split the first argument by IFS (spaces, tabs and line feeds). Expand each of them as if it was a glob. Join all the resulting strings and filenames with spaces. Print the result.\"\n\nThe second one looks like \"iterate through all arguments\". It's actually \"join all the arguments by the first character of IFS (space), split them by IFS and expand each of them as globs, and iterate on the resulting list\". The third one skips the joining part.\n\nQuoting variables prevents word splitting and glob expansion, and prevents the script from breaking when input contains spaces, line feeds, glob characters and such.\n\nStrictly speaking, only expansions themselves need to be quoted, but for stylistic reasons, entire arguments with multiple variable and literal parts are often quoted as one:\n\n```sh\n$HOME/$dir/dist/bin/$file        # Unquoted (bad)\n\"$HOME\"/\"$dir\"/dist/bin/\"$file\"  # Minimal quoting (good)\n\"$HOME/$dir/dist/bin/$file\"      # Canonical quoting (good)\n```\n\nWhen quoting composite arguments, make sure to exclude globs and brace expansions, which lose their special meaning in double quotes: `\"$HOME/$dir/src/*.c\"` will not expand, but `\"$HOME/$dir/src\"/*.c` will.\n\nNote that `$( )` starts a new context, and variables in it have to be quoted independently:\n\n```sh\necho \"This $variable is quoted $(but this $variable is not)\"\necho \"This $variable is quoted $(and now this \"$variable\" is too)\"\n```\n\n### Exceptions\nSometimes you want to split on spaces, like when building a command line.\n\n```sh\noptions=\"-j 5 -B\"\nmake $options file\n```\n\nJust quoting this doesn't work. Instead, you should have used an array (bash, ksh, zsh):\n\n```bash\noptions=(-j 5 -B) # ksh: set -A options -- -j 5 -B\nmake \"${options[@]}\" file\n```\n\nor a function (POSIX):\n\n```sh\nmake_with_flags() { make -j 5 -B \"$@\"; }\nmake_with_flags file\n```\n\nTo split on spaces but not perform glob expansion, Posix has a `set -f` to disable globbing.  You can disable word splitting by setting `IFS=''`.\n\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2087": {
    "remediation_points": 50000,
    "content": {
      "body": "## Quote 'EOF' to make here document expansions happen on the server side rather than on the client.\n\n### Problematic code:\n\n```sh\nssh host.example.com << EOF\n  echo \"Logged in on $HOSTNAME\"\nEOF\n\n### Correct code:\n\n```sh\nssh host.example.com << \"EOF\"\n  echo \"Logged in on $HOSTNAME\"\nEOF\n```\n\n### Rationale:\n\nWhen the end token of a here document is unquoted, parameter expansion and command substitution will happen on in contents of the here doc.\n\nThis means that before sending the commands to the server, the client replaces `$HOSTNAME` with localhost, thereby sending `echo \"Logged in on localhost\"` to the server. This has the effect of printing the client's hostname instead of the server's.\n\nScripts with any kind of variable use are especially problematic because all references will be expanded before the script run. For example,\n\n```sh\nssh host << EOF\n  x=\"$(uname -a)\"\n  echo \"$x\"\nEOF\n```\n\nwill never print anything, neither client nor server details, since before evaluation, it will be expanded to:\n\n```sh\n  x=\"Linux localhost ... x86_64 GNU/Linux\"\n  echo \"\"\n```\n\nBy quoting the here token, local expansion will not take place, so the server sees `echo \"Logged in on $HOSTNAME\"` which is expanded and printed with the server's hostname, which is usually the intention.\n\n### Exceptions:\n\nIf the client should expand some or all variables, this message can and should be ignored.\n\nTo expand a mix of local and remote variables, the here doc end token should be unquoted, and the remote variables should be escaped, e.g.\n\n```sh\nssh host.example.com << EOF\n  echo \"Logged in on \\$HOSTNAME from $HOSTNAME\"\nEOF\n```\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2088": {
    "remediation_points": 50000,
    "content": {
      "body": "## Tilde does not expand in quotes. Use $HOME.\n\n### Problematic code:\n\n```sh\nrm \"~/Desktop/$filename\"\n```\n\n### Correct code:\n\n```sh\nrm \"$HOME/Desktop/$filename\"\n```\n\n### Rationale:\n\nTilde does not expand to the user's home directory when it's single or double quoted. Use double quotes and `$HOME` instead.\n\nAlternatively, the `~/` can be left unquoted, as in `rm ~/\"Desktop/$filename\"`.\n\n### Exceptions\n\nIf you don't want the tilde to be expanded, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2089": {
    "remediation_points": 50000,
    "content": {
      "body": "# Quotes/backslashes will be treated literally. Use an array.\n\n### Problematic code:\n\n```sh\nargs='-lh \"My File.txt\"'\nls $args\n```\n\n### Correct code:\n\n```sh\nargs=(-lh \"My File.txt\")\nls \"${args[@]}\"\n```\n\n### Rationale:\n\nBash does not interpret data as code. Consider almost any other languages, such as Python:\n\n```sh\nprint 1+1   # prints 2\na=\"1+1\"\nprint a     # prints 1+1, not 2\n```\n\nHere, `1+1` is Python syntax for adding numbers. However, passing a literal string containing this expression does not cause Python to interpret it, see the `+` and produce the calculated result.\n\nSimilarly, `\"My File.txt\"` is Bash syntax for a single word with a space in it. However, passing a literal string containing this expression does not cause Bash to interpret it, see the quotes and produce the tokenized result.\n\nThe solution is to use an array instead, whenever possible.\n\nIf you due to `sh` compatibility can't use arrays, you can use `eval` instead. However, this is very insecure and easy to get wrong, leading to various forms of security vulnerabilities and breakage:\n\n```sh\nquote() { local q=${1//\\'/\\'\\\\\\'\\'}; echo \"'$q'\"; }\nargs=\"-lh $(quote \"My File.txt\")\"\neval ls \"$args\" # Do not use unless you understand implications\n```\n\nIf you ever accidentally forget to use proper quotes, such as with:\n\n```sh\nfor f in *.txt; do\n  args=\"-lh '$1'\" # Example security exploit\n  eval ls \"$args\" # Do not copy and use\ndone\n```\n\nThen you can use `touch \"'; rm -rf \\$'\\x2F'; '.txt\"`  (or someone can trick you into downloading a file with this name, or create a zip file or git repo containing it, or changing their nick and have your chat client create the file for a chat log, or...), and running the script to list your files will run the command `rm -rf /`.\n\n### Exceptions\n\nFew and far between.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2090": {
    "remediation_points": 50000,
    "content": {
      "body": "# Quotes/backslashes in this variable will not be respected.\n\nSee companion warning, [[SC2089]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2091": {
    "remediation_points": 50000,
    "content": {
      "body": "## Remove surrounding $() to avoid executing output.\n\n### Problematic code:\n\n```sh\nif $(which epstopdf)\nthen\n  echo \"Found epstopdf\"\nfi\n```\n\n### Correct code:\n\n```sh\nif which epstopdf\nthen\n  echo \"Found epstopdf\"\nfi\n```\n\n### Rationale:\n\nShellCheck has detected that you have a command that just consists of a command substitution.\n\nThis is typically done in order to try to get the shell to execute a command, because `$(..)` does indeed execute commands. However, it's also replaced by the output of that command.\n\nWhen you run `echo \"The date is $(date +%F)\"`, bash evalutes the `$(..)`. The command then becomes `echo \"The date is 2015-04-29\"`, which writes out the string `The date is 2015-04-29`\n\nThe problem is when you use `$(date +%F)` alone as a command. Bash evaluates the `$(..)`, and the command then becomes `2015-04-29`. There is no command called `2015-04-29`, so you get `bash: 2015-04-29: command not found`.\n\nSometimes this results in this confounding `command not found` messages. Other times you get even stranger issues, like the example problematic code which always evaluates to false.\n\nThe solution is simply to remove the surrounding `$()`. This will execute the command instead of the command's output.\n\n### Exceptions:\n\nIf you really want to execute the output of a command rather than the command itself, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2092": {
    "remediation_points": 50000,
    "content": {
      "body": "## Remove backticks to avoid executing output.\n\nBackticks does the same thing as `$(..)`. See [[SC2091]] for a description of the same problem with this syntax.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2094": {
    "remediation_points": 50000,
    "content": {
      "body": "# SC2094 Make sure not to read and write the same file in the same pipeline.\n\n### Problematic code:\n\n```sh\ngrep foo file.txt | sed -e 's/foo/bar/g' > file.txt\n```\n\n### Correct code:\n\n```sh\ngrep foo file.txt  | sed -e 's/foo/bar/g' > tmpfile && mv tmpfile file.txt\n```\n\n### Rationale:\n\nEach step in a pipeline runs in parallel.\n\nIn this case, `grep foo file.txt` will immediately try to read `file.txt` while `sed .. > file.txt` will immediately try to truncate it.\n\nThis is a race condition, and results in the file being partially or (far more likely) entirely truncated.\n\n### Exceptions\n\nYou can ignore this error if:\n\n* The file is a device or named pipe. These files don't truncate in the same way.\n* The command mentions the filename but doesn't read/write it, such as `echo log.txt > log.txt`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2095": {
    "remediation_points": 50000,
    "content": {
      "body": "## Add < /dev/null to prevent ssh from swallowing stdin.\n\nThe same error applies to multiple commands, like `ffmpeg` and `mplayer`.\n\n### Problematic code:\n\n```sh\nwhile read -r host\ndo\n  ssh \"$host\" \"uptime\"\ndone < hosts.txt\n```\n\n### Correct code:\n\n```sh\nwhile read -r host\ndo\n  ssh \"$host\" \"uptime\" < /dev/null\ndone < hosts.txt\n```\n### Rationale:\n\nCommands that process stdin will compete with the `read` statement for input. This is especially tricky for commands you wouldn't expect reads from stdin, like `ssh .. uptime`, `ffmpeg` and `mplayer`.\n\nThe most common symptom of this is a `while read` loop only running once, even though the input contains many lines. The is because the rest of the lines are swallowed by the offending command.\n\nTo refuse such commands input, redirect their stdin with `< /dev/null`. \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2096": {
    "remediation_points": 50000,
    "content": {
      "body": "## On most OS, shebangs can only specify a single parameter.\n\n### Problematic code:\n\n```sh\n#!/usr/bin/env bash -x\n```\n\n### Correct code:\n\n```sh\n#!/usr/bin/env bash\nset -x\n```\n\n### Rationale:\n\nMost operating systems, including Linux, FreeBSD and OS X, allow only a single parameter in the shebang. The example is equivalent to calling `env 'bash -x'` instead of `env 'bash' '-x'`, and it will therefore fail.\n\nThe shebang should be rewritten to use at most one parameter. Shell options can instead be set in the body of the script.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2097": {
    "remediation_points": 50000,
    "content": {
      "body": "## This assignment is only seen by the forked process.\n\n### Problematic code:\n\n```sh\nname=World cmd -m \"Hello $name\"\n```\n\n### Correct code:\n\n```sh\nexport name=World\ncmd -m \"Hello $name\"\n```\n\nTo prevent setting the variable, this can also be done in a subshell:\n\n```sh\n(\n   export name=World\n   cmd -m \"Hello $name\"\n) # 'name' does not leave this subshell\n```\n\n### Rationale:\n\nIn `name=World cmd \"$name\"`, `name=World` is passed in as part of the environment to `cmd` (i.e., in the `envp` parameter to [execve(2)](http://linux.die.net/man/2/execve)).  This means that `cmd` and its children will see the parameter, but no other processes will.\n\nHowever, `\"$name\"` is not expanded by `cmd`. `\"$name\"` is expanded by the shell before `cmd` is ever executed, and thus it will not use the new value.\n\nThe solution is to set the variable and export the variable first. If limited scope is desired, a `( subshell )` can be used.\n\n### Exceptions\n\nIn the strange and fabricated scenarios where the script and a program uses a variable name for two different purposes, you can ignore this message. This is hard to conceive, since scripts should use lowercase variable names specifically to avoid collisions with the environment.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2098": {
    "remediation_points": 50000,
    "content": {
      "body": "## This expansion will not see the mentioned assignment.\n\nSee companion warning [[SC2097]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2101": {
    "remediation_points": 50000,
    "content": {
      "body": "# Named class needs outer [], e.g. [[:digit:]\\].\n\n### Problematic code:\n\n```sh\ngzip file[:digit:]*.txt\n```\n\n### Correct code:\n\n```sh\ngzip file[[:digit:]]*.txt\n```\n\n### Rationale:\n\nPredefined character groups are supposed to be used inside character ranges. `[:digit:]` matches one of \"digt:\" just like `[abc]` matches one of \"abc\". `[[:digit:]]` matches a digit.\n\n### Exceptions\n\nWhen passing an argument to `tr` which parses these by itself without relying on globbing, you should quote it instead, e.g. `tr -d '[:digit:]'`\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2103": {
    "remediation_points": 50000,
    "content": {
      "body": "# Use a ( subshell ) to avoid having to cd back.\n\n### Problematic code:\n\n```sh\nfor dir in */\ndo\n  cd \"$dir\"\n  convert index.png index.jpg\n  cd ..\ndone\n```\n\n\n### Correct code:\n\n```sh\nfor dir in */\ndo\n  (\n  cd \"$dir\" || exit\n  convert index.png index.jpg\n  )\ndone\n```\n\nor\n\n```sh\nfor dir in */\ndo\n  cd \"$dir\" || exit\n  convert index.png index.jpg\n  cd ..\ndone\n```\n\n### Rationale:\n\nWhen doing `cd dir; somestuff; cd ..`, `cd dir` can fail when permissions are lacking, if the dir was deleted, or if `dir` is actually a file.\n\nIn this case, `somestuff` will run in the wrong directory and `cd ..` will take you to an even more wrong directory. In a loop, this will likely cause the next `cd` to fail as well, propagating this error and running these commands far away from the intended directories.\n\nCheck `cd`s exit status and/or use subshells to limit the effects of `cd`.\n\n### Exceptions\n\nIf you set variables you can't use a subshell. In that case, you should definitely check the exit status of `cd`, which will also silence this suggestion.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2105": {
    "remediation_points": 50000,
    "content": {
      "body": "## `break` is only valid in loops\n\n### Problematic code:\n\n```sh\ncase \"$1\" in\n    -v)\n       verbose=1\n       break\n       ;;\n    -d)\n       debug=1\nesac\n```\n\n### Correct code:\n\n```sh\ncase \"$1\" in\n    -v)\n       verbose=1\n       ;;\n    -d)\n       debug=1\nesac\n```\n### Rationale:\n\n`break` or `continue` was found outside a loop. These statements are only valid in loops. In particular, `break` is not required in `case` statements as there is no implicit fall-through.\n\nTo return from a function or sourced script, use `return`. To exit a script, use `exit`.\n\n### Exceptions:\n\nIt's possible to `break`/`continue` in a function without a loop. The call will then affect the loop -- if any -- that the function is invoked from. This is obviously not good coding practice.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2107": {
    "remediation_points": 50000,
    "content": {
      "body": "## Instead of [ a && b ], use [ a ] && [ b ].\n\n### Problematic code:\n\n```sh\n[ \"$1\" = \"-v\" && -z \"$2\" ]\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" = \"-v\" ] && [ -z \"$2\" ]\n```\n\n### Rationale:\n\n`&&` can not be used in a `[ .. ]` test expression. Instead, make two `[ .. ]` expressions and put the `&&` between them.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2108": {
    "remediation_points": 50000,
    "content": {
      "body": "## In [\\[..]], use && instead of -a.\n\n### Problematic code:\n\n```sh\n[[ \"$1\" = \"-v\" -a -z \"$2\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ \"$1\" = \"-v\" && -z \"$2\" ]]\n```\n\n### Rationale:\n\n`-a` for logical AND is not supported in a `[[ .. ]]` expression. Use `&&` instead.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2109": {
    "remediation_points": 50000,
    "content": {
      "body": "## Instead of [ a || b ], use [ a ] || [ b ].\n\n### Problematic code:\n\n```sh\n[ \"$1\" = \"-v\" || \"$1\" = \"-help\" ]\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" = \"-v\" ] || [ \"$1\" = \"-help\" ]\n```\n\n### Rationale:\n\n`||` can not be used in a `[ .. ]` test expression. Instead, make two `[ .. ]` expressions and put the `||` between them.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2110": {
    "remediation_points": 50000,
    "content": {
      "body": "## In [\\[..]], use || instead of -o.\n\n### Problematic code:\n\n```sh\n[[ \"$1\" = \"-v\" -o \"$1\" = \"-help\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ \"$1\" = \"-v\" || \"$1\" = \"-help\" ]]\n```\n\n### Rationale:\n\n`-o` for logical OR is not supported in a `[[ .. ]]` expression. Use `||` instead.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2114": {
    "remediation_points": 50000,
    "content": {
      "body": "## Warning: deletes a system directory. Use 'rm --' to disable this message.\n\n### Problematic code:\n\n```sh\nrm -rf /usr /lib/nvidia-current/xorg/xorg\n```\n\n### Correct code:\n\n```sh\nrm -rf /usr/lib/nvidia-current/xorg/xorg\n```\n\n### Rationale:\n\nThe example line of code was an actual bug in the [Bumblebee NVIDIA driver](https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/commit/a047be85247755cdbe0acce6f1dafc8beb84f2ac).\n\nDue to an accidental space, it deleted `/usr` instead of just the particular directory.\n\n### Exceptions:\n\nIn cases of chroot, initramfs and similar, it's reasonable to delete otherwise important directories. Due to this, Shellcheck will not warn if the command contains `--`:\n\n```sh\nrm -rf -- /usr\n```\n\nThis is an arbitrary convention to allow deleting such directories without having to use a [[directive]] to silence the warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2115": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use \"${var:?}\" to ensure this never expands to /* .\n\n### Problematic code:\n\n```sh\nrm -rf \"$STEAMROOT/\"*\n```\n\n### Correct code:\n\n```sh\nrm -rf \"${STEAMROOT:?}/\"*\n```\n\n### Rationale:\n\nIf `STEAMROOT` is empty, this will [end up deleting everything](https://github.com/ValveSoftware/steam-for-linux/issues/3671) in the system's root directory.\n\nUsing `:?` will cause the command to fail if the variable is null or unset. Similarly, you can use `:-` to set a default value if applicable.\n\nIn the case command substitution, assign to a variable first and then use `:?`. This is relevant even if the command seems simple and obviously correct, since forks and execs can fail due to external system limits and conditions, resulting in a blank substitution.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2116": {
    "remediation_points": 50000,
    "content": {
      "body": "## SC2116 Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.\n\n### Problematic code:\n\n```sh\na=$(echo $?)\n```\n\n### Correct code:\n\n```sh\na=\"$?\"\n```\n\n### Rationale:\n\nMost of the time, this is an useless echo meaning it isn't doing anything that the Shell can't already do. Having the shell expand the contents for you is simpler and more reliable. Just remember to double quote the argument!\n\n### Exceptions\n\nNone I am aware of at the moment.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2117": {
    "remediation_points": 50000,
    "content": {
      "body": "## To run commands as another user, use su -c or sudo.\n\n### Problematic code:\n\n```sh\nwhoami\nsu\nwhoami\n```\n\n### Correct code:\n\n```sh\nwhoami\nsudo whoami\n```\n\n### Rationale:\n\nIt's commonly believed that `su` makes a session run as another user. In reality, it starts an entirely new shell, independent of the one currently running your script.\n\n`su; whoami` will start a root shell and wait for it to exit before running `whoami`. It will not start a root shell and then proceed to run `whoami` in it.\n\nTo run commands as another user, use `sudo some command` or `su -c 'some command'`. `sudo` is preferred when available, as it doesn't require additional quoting and can be configured to run passwordless if desired.\n\n\n### Exceptions\n\nIf you're aware of the above and want to e.g. start an interactive shell for a user, feel free to ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2119": {
    "remediation_points": 50000,
    "content": {
      "body": "# Use foo \"$@\" if function's $1 should mean script's $1.\n\nSee companion warning [[SC2120]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2120": {
    "remediation_points": 50000,
    "content": {
      "body": "# foo references arguments, but none are ever passed.\n\n### Problematic code:\n\n```sh\nsayhello() {\n  echo \"Hello $1\"\n}\nsayhello\n```\n\n`./myscript World` just prints \"Hello \" instead of \"Hello World\".\n\n### Correct code:\n\n```sh\nsayhello() {\n  echo \"Hello $1\"\n}\nsayhello \"$@\"\n```\n\n`./myscript World` now prints \"Hello World\".\n\n### Rationale:\n\nIn a function, `$1` and up refers to the function's parameters, not the script's parameters.\n\nIf you want to process your script's parameters in a function, you have to explicitly pass them. You can do this with `myfunction \"$@\"`.\n\nNote that `\"$@\"` refers to the current context's positional parameters, so if you call a function from a function, you have to pass in `\"$@\"` to both of them:\n\n```sh\nfirst() { second \"$@\"; }\nsecond() { echo \"The first script parameter is: $1\"; }\nfirst \"$@\"\n```\n\n### Exceptions\n\nIf the parameters are optional and you currently just don't want to use them, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2121": {
    "remediation_points": 50000,
    "content": {
      "body": "# To assign a variable, use just 'var=value', no 'set ..'.\n\n### Problematic code:\n\n```sh\nset var=42\nset var 42\n```\n\n### Correct code:\n\n```sh\nvar=42\n```\n\n### Rationale:\n\n`set` is not used to set or assign variables in Bourne shells. It's used to set shell options and positional parameters.\n\nTo assign variables, use `var=value` with no `set` or other qualifiers.\n\n### Exceptions\n\nIf you actually do want to set positional parameters, simply quoting them or using `--` will make shellcheck stop warning, e.g. `set -- var1 var2` or `set \"foo=bar\"`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2122": {
    "remediation_points": 50000,
    "content": {
      "body": "## >= is not a valid operator. Use '! a < b' instead.\n\n### Problematic code:\n\n```sh\n[[ a &lt;= b ]]\n```\n\n### Correct code:\n\n```sh\n[[ ! a > b ]]\n```\n\n### Rationale:\n\nThe operators `<=` and `>=` are not supported by Bourne shells. Instead of \"less than or equal\", rewrite as \"not greater than\".\n\n### Exceptions\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2123": {
    "remediation_points": 50000,
    "content": {
      "body": "## PATH is the shell search path. Use another name.\n\n### Problematic code:\n\n```sh\nPATH=/my/dir\ncat \"$PATH/myfile\"\n```\n\n### Correct code:\n\nGood practice: always use lowercase for unexported variables.\n\n```sh\npath=/my/dir\ncat \"$path/myfile\"\n```\n\nBad practice: use another uppercase name.\n\n```sh\nMYPATH=/my/dir\ncat \"$MYPATH/myfile\"\n```\n\n### Rationale:\n\n`PATH` is where the shell looks for the commands it executes. By inadvertently overwriting it, the shell will be unable to find commands (like `cat` in this case).\n\nYou get this warning when ShellCheck suspects that you didn't meant to overwrite it (because it's a single path with no path separators).\n\nBest shell scripting practice is to always use lowercase variable names to avoid accidentally overwriting exported and internal variables.\n\n### Exceptions\n\nIf you're aware of the above and really do want to set your shell search path to `/my/dir`, you can ignore this warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2124": {
    "remediation_points": 50000,
    "content": {
      "body": "## Assigning an array to a string! Assign as array, or use * instead of @ to concatenate.\n\n### Problematic code:\n\n```sh\nvar=$@\nfor i in $var; do ..; done\n```\n\nor\n\n```sh\nset -- Hello World\nmsg=$@\necho \"You said $msg\"\n```\n\n### Correct code:\n\n```sh\nvar=( \"$@\" )\nfor i in \"${var[@]}\"; do ..; done\n```\n\nor\n\n```sh\nset -- Hello World\nmsg=$*\necho \"You said $msg\"\n```\n\n### Rationale:\n\nArrays and `$@` can contain multiple elements. Simple variables contain only one. When assigning multiple elements to one element, the default behavior depends on the shell (bash concatenates with spaces, zsh concatenates with first char of `IFS`).\n\nSince doing this usually indicates a bug, ShellCheck warns and asks you to be explicit about what you want.\n\nIf you want to assign N elements as N elements, use an array, e.g. `myArray=( \"$@\" )`.\n\nIf you want to assign N elements as 1 element by concatenating them, use `*` instead of `@`, e.g. `myVar=${myArray[*]}` (this separates elements with the first character of `IFS`, usually space).\n\nThe same is true for `${@: -1}`, which results in 0 or 1 elements: `var=${*: -1}` assigns the last element or an empty string.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2125": {
    "remediation_points": 50000,
    "content": {
      "body": "## Brace expansions and globs are literal in assignments. Quote it or use an array.\n\n### Problematic code:\n\n```sh\nfoo={1..9}\necho $foo\n```\n\n### Correct code:\n\n```sh\nfoo=( {1..9} )\necho \"${foo[@]}\"\n```\n\n### Rationale:\n\n`echo *.png {1..9}` expands to all png files and numbers from 1 to 9, but `var=*.png` or `var={1..9}` will just assign the literal strings `'*.png'` and `'{1..9}'`.\n\nTo make the variable contain all png files or 1 through 9, use an array as demonstrated.\n\nIf you intended to assign these values as literals, quote them (e.g. `var=\"*.png\"`).\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2126": {
    "remediation_points": 50000,
    "content": {
      "body": "## Consider using grep -c instead of grep|wc.\n\n### Problematic code:\n\n```sh\ngrep foo | wc -l\n```\n\n### Correct code:\n\n```sh\ngrep -c foo\n```\n\n### Rationale:\n\nThis is purely a stylistic issue. `grep` can count lines without piping to `wc`.\n\nNote that in many cases, this number is only used to see whether there are matches (i.e. `> 0`). In these cases, it's better and more efficient to use `grep -q` and check its exit status:\n\n```sh\nif grep -q pattern file\nthen\n  echo \"The file contains the pattern\"\nfi\n```\n\n### Exceptions\n\nIf you e.g. want to count characters instead of lines, and you actually care about the number and not just whether it's greater than 0.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2128": {
    "remediation_points": 50000,
    "content": {
      "body": "## Expanding an array without an index only gives the first element.\n\n### Problematic code:\n\n```sh\nmyarray=(foo bar)\nfor f in $myarray\ndo\n  cat \"$f\"\ndone\n```\n\n### Correct code:\n\n```sh\nmyarray=(foo bar)\nfor f in \"${myarray[@]}\"\ndo\n  cat \"$f\"\ndone\n```\n\n### Rationale:\n\nWhen referencing arrays, `$myarray` is equivalent to `${myarray[0]}` -- it results in only the first of multiple elements.\n\nTo get all elements as separate parameters, use the index `@` (and make sure to double quote). In the example, `echo \"${myarray[@]}\"` is equivalent to `echo \"foo\" \"bar\"`.\n\nTo get all elements as a single parameter, concatenated by the first character in `IFS`, use the index `*`. In the example, `echo \"${myarray[*]}\"` is equivalent to `echo \"foo bar\"`.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2129": {
    "remediation_points": 50000,
    "content": {
      "body": "## Consider using { cmd1; cmd2; } >> file instead of individual redirects.\n\n### Problematic code:\n\n```sh\necho foo >> file\ndate >> file\ncat stuff  >> file\n\n```\n\n### Correct code:\n\n```sh\n{\n  echo foo\n  date\n  cat stuff\n} >> file\n```\n\n### Rationale:\n\nRather than adding `>> something` after every single line, you can simply group the relevant commands and redirect the group.\n\n### Exceptions\n\nThis is mainly a stylistic issue, and can freely be ignored.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2130": {
    "remediation_points": 50000,
    "content": {
      "body": "## -eq is for integer comparisons. Use = instead.\n\n### Problematic code:\n\n```sh\n[[ $foo -eq \"Y\" ]]\n```\n\n### Correct code:\n\n```sh\n[[ $foo = \"Y\" ]]\n```\n\n### Rationale:\n\nShells have two sets of comparison operators: for integers (`-eq`, `-gt`, ...) and strings (`=`, `>`, ...). ShellCheck has noticed that you're using an integer comparison with string data.\n\nIf you are in fact comparing integers, double check your parameters. Certain mistakes like `$$foo` or `${bar}}` can introduce non-numeric characters into otherwise numeric arguments.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2139": {
    "remediation_points": 50000,
    "content": {
      "body": "## This expands when defined, not when used. Consider escaping.\n\n### Problematic code:\n\n```sh\nalias whereami=\"echo $PWD\"\n```\n\n### Correct code:\n\n```sh\nalias whereami='echo $PWD'\n```\n\n### Rationale:\n\nWith double quotes, this particular alias will be defined as `echo /home/me`, so it will always print the same path. This is rarely intended.\n\nBy using single quotes or escaping any expansions, we define the alias as `echo $PWD`, which will be expanded when we use the alias. This is the far more common use case.\n\n### Exceptions\n\nIf you don't mind that your alias definition is expanded at define time, you can ignore this warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2140": {
    "remediation_points": 50000,
    "content": {
      "body": "##  Word is on the form \"A\"B\"C\" (B indicated). Did you mean \"ABC\" or \"A\\\"B\\\"C\"?\n\n### Problematic code:\n\n```sh\necho \"<img src=\"foo.png\" />\" > file.html\n```\n\nor\n\n```sh\nexport \"var\"=\"42\"\n```\n\n### Correct code:\n\n```sh\necho \"<img src=\\\"foo.png\\\" />\" > file.html\n```\n\nor\n\n```sh\nexport \"var=42\"\n```\n\n\n### Rationale:\n\nThis warning triggers when an unquoted literal string is found suspiciously sandwiched between two double quoted strings.\n\nThis usually indicates one of:\n\n- quotes that were supposed to be nested, and therefore need to be escaped (like the `<img>` example)\n- quotes that are just plain unnecessary (like the `export` example).\n\nWithout escaping, the inner two quotes of the sandwich (the end quote of the first section and the start quote of the second section) are no-ops. The following two statements are identical, so the quotes that were intended to be part of the html output are instead removed:\n\n```sh\necho \"<img src=\"foo.png\" />\" > file.html\necho \"<img src=foo.png />\" > file.html\n```\n\nSimilarly, these statements are identical, but work as intended:\n\n```sh\nexport \"var\"=\"42\"\nexport \"var=42\"\n```\n\n### Exceptions\n\nIf you know that the quotes are ineffectual but you prefer it stylistically, you can ignore this message.\n\nIt's common not to realize that double quotes can span multiple elements, or to stylistically prefer to quote individual variables. For example, these statements are identical, but the first is laboriously and redundantly quoted:\n\n```sh\nhttp://\"$user\":\"$password\"@\"$host\"/\"$path\"\n\"http://$user:$password@$host/$path\"\n```\n\nWhen ShellCheck detects the first style (i.e. the double quotes include only a single element each), it will suppress the warning.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2141": {
    "remediation_points": 50000,
    "content": {
      "body": "## Did you mean IFS=$'\\t' ?\n\n### Problematic code:\n\n```sh\nIFS=\"\\t\"\n```\n\n### Correct code:\n\n```sh\nIFS=$'\\t'\n```\n\n### Rationale:\n\n`IFS=\"\\t\"` splits on backslash and the letter \"t\". `IFS=$'\\t'` splits on tab.\n\n### Exceptions\n\nIt's extremely rare to want to split on the letter \"n\" or \"t\", rather than linefeed or tab.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2142": {
    "remediation_points": 50000,
    "content": {
      "body": "## Aliases can't use positional parameters. Use a function.\n\n### Problematic code:\n\n```sh\nalias archive='mv \"$@\" /backup'\n```\n\n### Correct code:\n\n```sh\narchive() { mv \"$@\" /backup; }\n\n```\n\n### Rationale:\n\nAliases just substitute the start of a command with something else. They therefore can't use positional parameters, such as `$1`. Rewrite your alias as a function.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2143": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use grep -q instead of comparing output with [ -n .. ].\n### Problematic code:\n\n```sh\nif [ \"$(find . | grep 'IMG[0-9]')\" ]\nthen\n  echo \"Images found\"\nfi\n```\n\n### Correct code:\n\n```sh\nif find . | grep -q 'IMG[0-9]'\nthen\n  echo \"Images found\"\nfi\n```\n\n### Rationale:\n\nThe problematic code has to iterate the entire directory and read all matching lines into memory before making a decision.\n\nThe correct code is cleaner and stops at the first matching line, avoiding both iterating the rest of the directory and reading data into memory.\n\n### Exceptions\n\nThe `pipefail` bash option may interfere with this rewrite, since the `if` will now in effect be evaluating the statuses of all commands instead of just the last one. Be careful using them together.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2144": {
    "remediation_points": 50000,
    "content": {
      "body": "##  -e doesn't work with globs. Use a for loop.\n\n### Problematic code:\n\n```sh\nif [ -e dir/*.mp3 ]\nthen\n  echo \"There are mp3 files.\"\nfi\n```\n\n### Correct code:\n\n```sh\nfor file in dir/*.mp3\ndo\n  if [ -e \"$file\" ]\n  then\n    echo \"There are mp3 files\"\n    break\n  fi\ndone\n```\n\n### Rationale:\n\n`[ -e file* ]` only works if there's 0 or 1 matches. If there are multiple, it becomes `[ -e file1 file2 ]`, and the test fails.\n\n`[[ -e file* ]]` doesn't work at all.\n\nInstead, use a for loop to expand the glob and check each result individually.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2145": {
    "remediation_points": 50000,
    "content": {
      "body": "## Argument mixes string and array. Use * or separate argument.\n\n### Problematic code:\n\n```sh\nprintf \"Error: %s\\n\" \"Bad parameters: $@\"\n```\n\n### Correct code:\n\n```sh\nprintf \"Error: %s\\n\" \"Bad parameters: $*\"\n```\n\n### Rationale:\n\nThe behavior when concatenating a string and array is rarely intended. The preceeding string is prefixed to the first array element, while the succeeding string is appended to the last one. The middle array elements are unaffected.\n\nE.g., with the parameters `foo`,`bar`,`baz`, `\"--flag=$@\"` is equivalent to the three arguments `\"--flag=foo\" \"bar\" \"baz\"`.\n\nIf the intention is to concatenate all the array elements into one argument, use `$*`. This concatenates based on `IFS`.\n\nIf the intention is to provide each array element as a separate argument, put the array expansion in its own argument.\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2146": {
    "remediation_points": 50000,
    "content": {
      "body": "## This action ignores everything before the -o. Use \\\\( \\\\) to group.\n\n### Problematic code:\n\n```sh\nfind . -name '*.avi' -o -name '*.mkv' -exec cp {} /media \\;\n```\n\n### Correct code:\n\n```sh\nfind . \\( -name '*.avi' -o -name '*.mkv' \\) -exec cp {} /media \\;\n```\n\n### Rationale:\n\nIn `find`, two predicates with no operator between them is considered a logical, short-circuiting AND (as if using `-a`). E.g., `-name '*.mkv' -exec ..` is the same as `-name '*.mkv' -a -exec ..`.\n\n`-a` has higher precedence than `-o`, so `-name '*.avi' -o -name '*.mkv' -a -exec ..` is equivalent to `-name '*.avi' -o \\( -name '*.mkv' -a -exec .. \\)`.\n\nIn other words, the problematic code means \"if name matches `*.avi`, do nothing. Otherwise, if it matches `*.mkv`, execute a command.\".\n\nIn the correct code, we use `\\( \\)` to group to get the evaluation order we want. The correct code means \"if name matches `*.avi` or `*.mkv`, then execute a command\", which was what was intended.\n\n### Exceptions\n\nIf you're aware of this, you can either ignore this error or group to make it explicit. For example, to decompress all gz files except tar.gz, you can use:\n\n```sh\nfind . -name '*.tar.gz' -o \\( -name '*.gz' -exec gzip -d {} + \\)\n```\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2147": {
    "remediation_points": 50000,
    "content": {
      "body": "##  Literal tilde in PATH works poorly across programs.\n\n### Problematic code:\n\n```sh\nPATH=\"$PATH:~/bin\"\n```\n\n### Correct code:\n\n```sh\nPATH=\"$PATH:$HOME/bin\"\n```\n\n### Rationale:\n\nHaving literal `~` in PATH is a bad idea. Bash handles it, but nothing else does.\n\nThis means that even if you're always using Bash, you should avoid it because any invoked program that relies on PATH will effectively ignore those entries.\n\nFor example, `make` may say `foo: Command not found` even though `foo` works fine from the shell and Make and Bash both use the same PATH. You'll get similar messages from any non-bash scripts invoked, and `whereis` will come up empty.\n\nUse `$HOME` or full path instead.\n\n### Exceptions\n\nIf your directory name actually contains a literal tilde, you can ignore this message.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2148": {
    "remediation_points": 50000,
    "content": {
      "body": "##  Tips depend on target shell and yours is unknown. Add a shebang.\n\n### Problematic code:\n\n```sh\necho \"$RANDOM\"   # Does this work\n```\n\n### Correct code:\n\n```sh\n#!/bin/sh\necho \"$RANDOM\"  # Unsupported in sh. Produces warning.\n```\n\nor\n\n```sh\n#!/bin/bash\necho \"$RANDOM\"  # Supported in bash. No warnings.\n```\n\n### Rationale:\n\nDifferent shells support different features. To give effective advice, ShellCheck needs to know which shell your script is going to run on. You will get a different numbers of warnings about different things depending on your target shell.\n\nShellCheck normally determines your target shell from the shebang (having e.g. `#!/bin/sh` as the first line). The shell can also be specified from the CLI with `-s`, e.g. `shellcheck -s sh file`.\n\nIf you don't specify shebang nor `-s`, ShellCheck gives this message and proceeds with some default (`bash`).\n\nNote that this error can not be ignored with a [[directive]]. It is not a suggestion to improve your script, but a warning that ShellCheck lacks information it needs to be helpful.\n\n### Exceptions\n\nNone. Please either add a shebang or use `-s`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2149": {
    "remediation_points": 50000,
    "content": {
      "body": "## Remove $/${} for numeric index, or escape it for string.\n\n### Problematic code:\n\n```sh\n# Regular array\nindex=42\necho $((array[$index]))\n```\n\nor\n\n```sh\n# Associative array\nindex=banana\necho $((array[$index]))\n```\n\n### Correct code:\n\n# Regular array\nindex=42\necho $((array[index]))\n```\n\nor\n\n```sh\n# Associative array\nindex=banana\necho $((array[\\$index]))\n```\n\n### Rationale:\n\nFor a numerically indexed array, the `$` is mostly pointless and can be removed like in [[SC2004]].\n\nFor associative arrays, the `$` should be escaped to avoid accidental dereferencing:\n\n```sh\ndeclare -A array\nindex='$1'\narray[$index]=42\necho \"$(( array[$index] ))\"    # bash: array: bad array subscript\necho \"$(( array[\\$index] ))\"   # 42\n```\n\n### Exceptions\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2150": {
    "remediation_points": 50000,
    "content": {
      "body": "## -exec does not automatically invoke a shell. Use -exec sh -c .. for that.\n\n### Problematic code:\n\n```sh\nfind . -type f -exec 'cat {} | wc -l' \\;\n```\n\n### Correct code:\n\n```sh\nfind . -type f -exec sh -c 'cat {} | wc -l' \\;         # Insecure\nfind . -type f -exec sh -c 'cat \"$1\" | wc -l' _ {} \\;  # Secure\n```\n\nSometimes the command can also be rewritten to not require `find` to invoke a shell:\n\n```sh\nfind . -type f -exec wc -l {} \\; | cut -d ' ' -f 1\n```\n\n### Rationale:\n\nfind `-exec` and `-execdir` uses `execve(2)` style semantics, meaning it expects an executable and zero or more arguments that should be passed to it.\n\nIt does not use `system(3)` style semantics, meaning it does not accept a shell command as a string, to be parsed and evaluated by the system's command interpreter.\n\nIf you want `find` to execute a shell command, you have to specify `sh` (or `bash`) as the executable, `-c` as first argument and your shell command as the second.\n\nTo prevent command injection, the filename can be passed as a separate argument to sh and referenced as a positional parameter.\n\n### Exceptions\n\nThis warning would trigger falsely if executing a program with spaces in the path, if no other arguments were specified.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2151": {
    "remediation_points": 50000,
    "content": {
      "body": "## Only one integer 0-255 can be returned. Use stdout for other data.\n\n### Problematic code:\n\n```sh\nmyfunc() {\n  return foo bar\n}\n```\n\n### Correct code:\n\n```sh\nmyfunc() {\n  echo foo\n  echo bar\n  return 0\n}\n```\n\n### Rationale:\n\nIn bash, `return` can only be used to signal success or failure (0 = success, 1-255 = failure).\n\nTo return textual or multiple values from a function, write them to stdout and capture them with command substitution instead.\n\nSee [[SC2152]] for more information.\n\n### Exceptions:\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2152": {
    "remediation_points": 50000,
    "content": {
      "body": "## Can only return 0-255. Other data should be written to stdout.\n\n### Problematic code:\n\n```sh\nmyfunc() {\n  return \"Hello $USER\"\n}\n```\n\n### Correct code:\n\n```sh\nmyfunc() {\n  echo \"Hello $USER\"\n  return 0\n}\n```\n\n### Rationale:\n\nIn many languages, `return` is used to return from the function with a final result.\n\nIn bash, `return` can only be used to signal success or failure (0 = success, 1-255 = failure), more akin to `throw/raise` in other languages.\n\nResults should instead be written to stdout and captured:\n\n```sh\nmessage=$(myfunc)\necho \"The function wrote: $message\"\n```\n\nIn functions that return small integers, such as getting the cpu temperature, the value should still be written to stdout. `return` should be reserved for error conditions, such as \"can't determine CPU temperature\".\n\n### Exceptions:\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2153": {
    "remediation_points": 50000,
    "content": {
      "body": "## Possible Misspelling: MYVARIABLE may not be assigned, but MY_VARIABLE is.\n\n### Problematic code:\n\n```sh\nMY_VARIABLE=\"hello world\"\necho \"$MYVARIABLE\"\n```\n\n### Correct code:\n\n```sh\nMY_VARIABLE=\"hello world\"\necho \"$MY_VARIABLE\"\n```\n\n### Rationale:\n\nShellCheck has noticed that you reference a variable that is not assigned in the script, which has a name remarkably similar to one that is explicitly assigned. You should verify that the variable name is spelled correctly.\n\nNote: This error only triggers for environment variables (all uppercase variables), and only when they have names similar to something assigned in the script. If the variable is script-local, it should by convention have a lowercase name, and will in that case be caught by [SC2154] whether or not it resembles another name.\n\n### Exceptions:\n\nIf you've double checked and ensured that you did not intend to reference the specified variable, you can disable this message with a [[directive]]. The message will also not appear for guarded references like `${ENVVAR:-default}` or `${ENVVAR:?Unset error message here}`.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2154": {
    "remediation_points": 50000,
    "content": {
      "body": "## var is referenced but not assigned.\n\n### Problematic code:\n\n```sh\nvar=name\nn=42\necho \"$var_$n.jpg\"   # overextended\n```\n\nor\n\n```sh\ntarget=\"world\"\necho \"hello $tagret\"  # misspelled\n```\n\nor\n\n```sh\necho \"Result: ${mycmd -a myfile}\"  # trying to execute commands\n```\n\n### Correct code:\n\n```sh\nvar=name\nn=42\necho \"${var}_$n.jpg\"\n```\n\nor\n\n```sh\ntarget=\"world\"\necho \"hello $target\"\n```\n\nor\n\n```sh\necho \"Result: $(mycmd -a myfile)\"\n```\n\n### Rationale:\n\nShellCheck has noticed that you reference a variable that is not assigned. Double check that the variable is indeed assigned, and that the name is not misspelled.\n\nNote: This message only triggers for variables with lowercase characters in their name (`foo` and `kFOO` but not `FOO`) due to the standard convention of using lowercase variable names for unexported, local variables.\n\n### Exceptions:\n\nShellCheck does not attempt to figure out runtime or dynamic assignments like with `source \"$(date +%F).sh\"` or `eval var=value`.\n\nIf you know for a fact that the variable is set, you can use `${var:?}` to fail if the variable is unset (or empty), or explicitly initialize/declare it with `var=\"\"` or `declare var`. You can also disable the message with a [[directive]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2155": {
    "remediation_points": 50000,
    "content": {
      "body": "## Declare and assign separately to avoid masking return values.\n\n### Problematic code:\n\n```sh\nexport foo=\"$(mycmd)\"\n```\n\n### Correct code:\n\n```sh\nexport foo\nfoo=$(mycmd)\n```\n\n### Rationale:\n\nIn the original code, the return value of `mycmd` is ignored, and `export` will instead always return true. This may prevent conditionals, `set -e` and traps from working correctly.\n\nWhen first marked for export and assigned separately, the return value of the assignment will be that of `mycmd`. This avoids the problem.\n\n### Exceptions:\n\nIf you intend to ignore the return value of an assignment, you can either ignore this warning or use\n\n```sh\nexport foo\nfoo=$(mycmd) || true\n```\n\nShellcheck does not warn about `export foo=bar` because `bar` is a literal and not a command substitution with an independent return value. It also does not warn about `local -r foo=$(cmd)`, where declaration and assignment must be in the same command.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2156": {
    "remediation_points": 50000,
    "content": {
      "body": "## Injecting filenames is fragile and insecure. Use parameters.\n\n### Problematic code:\n\n```sh\nfind . -name '*.mp3' -exec sh -c 'i=\"{}\"; sox \"$i\" \"${i%.mp3}.wav\"' \\;\n```\n\n### Correct code:\n\n```sh\nfind . -name '*.mp3' -exec sh -c 'i=\"$1\"; sox \"$i\" \"${i%.mp3}.wav\"' _ {} \\;\n```\n\n### Rationale:\n\nIn the problematic example, the filename is passed by injecting it into a shell string. Any shell metacharacters in the filename will be interpreted as part of the script, and not as part of the filename. This can break the script and allow arbitrary code execution exploits.\n\nIn the correct example, the filename is passed as a parameter. It will be safely treated as literal text. The `_` is a dummy string that becomes `$0` in the script.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2157": {
    "remediation_points": 50000,
    "content": {
      "body": "## Argument to implicit -n is always true due to literal strings.\n\n### Problematic code:\n\n```sh\nif [ \"$foo \" ]\nthen\n  echo \"this is always true\"\nfi\n```\n\n### Correct code:\n\n```sh\nif [ \"$foo\" ]\nthen\n  echo \"correctly checks value\"\nfi\n```\n\n### Rationale:\n\nSince `[ str ]` checks that the string is non-empty, the space inside the quotes in the problematic code causes the test to always be true, since a string with a space can not be empty.\n\nSometimes this is also caused by overquoting an example, e.g. `[ \"$foo -gt 0\" ]`, which is always true for the same reason. The intention here was `[ \"$foo\" -gt 0 ]`.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2158": {
    "remediation_points": 50000,
    "content": {
      "body": "## [ false ] is true. Remove the brackets\n\n### Problematic code:\n\n```sh\nif [ false ]\nthen\n  echo \"triggers anyways\"\nfi\n```\n\n### Correct code:\n\n```sh\nif false\nthen\n  echo \"never triggers\"\nfi\n```\n\n### Rationale:\n\n`[ str ]` checks whether `str` is non-empty. It doesn't matter if `str` is `false`, it will still be evaluated for non-emptyness.\n\nInstead, use the command `false` which -- as the manual puts it -- does nothing, unsuccessfully.\n\n### Exceptions:\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2159": {
    "remediation_points": 50000,
    "content": {
      "body": "## [ 0 ] is true. Use 'false' instead\n\n### Problematic code:\n\n```sh\nif [ 0 ]\nthen\n  echo \"always triggers\"\nfi\n```\n\n### Correct code:\n\n```sh\nif false\nthen\n  echo \"never triggers\"\nfi\n```\n\n### Rationale:\n\n`[ str ]` checks whether `str` is non-empty. It doesn't matter if `str` is `0`, it will still be evaluated for non-emptyness.\n\nInstead, use the command `false` which -- as the manual puts it -- does nothing, unsuccessfully.\n\n### Exceptions:\n\nNone\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2160": {
    "remediation_points": 50000,
    "content": {
      "body": "## Instead of '[ true ]', just use 'true'.\n\n### Problematic code:\n\n```sh\nif [ true ]\nthen\n  echo \"always triggers\"\nfi\n```\n\n### Correct code:\n\n```sh\nif true\nthen\n  echo \"always triggers\"\nfi\n```\n\n### Rationale:\n\nThis is a stylistic suggestion to use `true` instead of `[ true ]`.\n\n`[ true ]` seems to suggest that the value \"true\" is somehow relevant to the statement. This is not the case, it doesn't matter. You can replace it with `[ false ]` or `[ wombat ]`, and it will still always be true:\n\nString  | In brackets  | Outside brackets\n--------|--------------|-----------------\ntrue    | true         | true\nfalse   | true         | false\nwombat  | true         | unknown command\n\nIt's therefore better to use it without brackets, so that the \"true\" actually matters.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2161": {
    "remediation_points": 50000,
    "content": {
      "body": "## Instead of '[ 1 ]', use 'true'.\n\n### Problematic code:\n\n```sh\nwhile [ 1 ]\ndo\n  echo \"infinite loop\"\ndone\n```\n\n### Correct code:\n\n```sh\nwhile true\ndo\n  echo \"infinite loop\"\ndone\n```\n\n### Rationale:\n\nThis is a stylistic suggestion to use `true` instead of `[ 1 ]`.\n\n`[ 1 ]` seems to suggest that the value \"1\" is somehow relevant to the statement. This is not the case: it doesn't matter. You can replace it with `[ 0 ]` or `[ wombat ]`, and it will still always be true.\n\nIf you instead use `true`, the value is actually considered and can be inverted by replacing with `false`.\n\nOn bash, you can also use `(( 1 ))`, which evaluates to true much like in C. `(( 0 ))` is similarly false.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2162": {
    "remediation_points": 50000,
    "content": {
      "body": "## read without -r mangles backslashes\n\n### Problematic code:\n\n```sh\necho \"Enter name:\"\nread name\n```\n\n### Correct code:\n\n```sh\necho \"Enter name:\"\nread -r name\n```\n\n### Rationale:\n\nBy default, `read` will interpret backslashes before spaces and line feeds, and otherwise strip them. This is rarely expected or desired.\n\nNormally you just want to read data, which is what `read -r` does. All `read`s should use `-r` unless you have a good reason not to.\n\nNote that `read -r` will still strip leading and trailing spaces. `IFS=\"\" read -r` prevents this.\n\n### Exceptions:\n\nIf you want backslashes to affect field splitting and line terminators instead of being read, you can disable this message with a [[directive]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2163": {
    "remediation_points": 50000,
    "content": {
      "body": "## Exporting an expansion rather than a variable.\n\n### Problematic code:\n\n```sh\nMYVAR=foo\nexport $MYVAR\n```\n\n### Correct code:\n\n```sh\nMYVAR=foo\nexport MYVAR\n```\n\n### Rationale:\n\n`export` takes a variable name, but shellcheck has noticed that you give it an expanded variable instead. The problematic code does not export `MYVAR` but a variable called `foo` if any.\n\n### Exceptions:\n\nIf you do want to export the variable's value, e.g. due to indirection, you can disable this message with a directive:\n\n```sh\n# shellcheck disable=SC2163\nexport \"$MYVAR\"\n```\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2164": {
    "remediation_points": 50000,
    "content": {
      "body": "## Use cd ... || exit in case cd fails.\n\n### Problematic code:\n\n```sh\ncd generated_files\nrm -r *.c\n```\n\n### Correct code:\n\n```sh\ncd generated_files || exit\nrm -r *.c\n```\n\n### Rationale:\n\n`cd` can fail for a variety of reasons: misspelled paths, missing directories, missing permissions, broken symlinks and more.\n\nIf/when it does, the script will keep going and do all its operations in the wrong direction. This can be messy, especially if the operations involve creating or deleting a lot of files.\n\nYou should therefore always check the condition of `cd`, either with `|| exit` as suggested, or things like `if cd somewhere; then ...; fi`.\n\n### Exceptions:\n\nShellCheck does not give this warning when `cd` is on the left of a `||` or `&&`, or the condition of a `if`, `while` or `until` loop. Having a `set -e` command anywhere in the script will disable this message, even though it won't necessarily prevent the issue.\n\nIf you are accounting for `cd` failures in a way shellcheck doesn't realize, you can disable this message with a [[directive]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2165": {
    "remediation_points": 50000,
    "content": {
      "body": "## This nested loop overrides the index variable of its parent.\n\nAnd companion warning \"This parent loop has its index variable overridden.\"\n\n### Problematic code:\n\n```sh\nfor((i=0; i<10; i++))\ndo\n  for i in *\n  do\n    echo \"$i\"\n  done\ndone\n```\n\n### Correct code:\n\n```sh\nfor((i=0; i<10; i++))\ndo\n  for j in *\n  do\n    echo \"$j\"\n  done\ndone\n```\n\n### Rationale:\n\nWhen nesting loops, especially arithmetic for loops, using the same loop variable can cause unexpected results.\n\nIn the problematic code, `i` will contain the last filename from the inner loop, which will be interpreted as a value in the next iteration out the outer loop. This results in either an infinite loop or a syntax error, depending on whether the last filename is a valid shell variable name.\n\nIn nested for-in loops, variable merely shadow each other and won't cause infinite loops or syntax errors, but reusing the variable name is rarely intentional.\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2166": {
    "remediation_points": 50000,
    "content": {
      "body": "## Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.\n\nAnd likewise, prefer `[ p ] || [ q ]` over `[ p -o q ]`.\n\n### Problematic code:\n\n```sh\n[ \"$1\" = \"test\" -a -z \"$2\" ]\n```\n\n### Correct code:\n\n```sh\n[ \"$1\" = \"test\" ] && [ -z \"$2\" ]\n```\n\n### Rationale:\n\n`-a` and `-o` to mean AND and OR in a `[ .. ]` test expression is not well defined. They are obsolescent extensions in [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html) and their behavior is almost always undefined.\n\nUsing multiple `[ .. ]` expressions with shell AND/OR operators `&&` and `||` is well defined and therefore preferred (but note that they have equal precedence, while `-a`/`-o` is unspecified but often implemented as `-a` having higher precedence).\n\n### Exceptions:\n\nNone.\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2167": {
    "remediation_points": 50000,
    "content": {
      "body": "## This parent loop has its index variable overridden.\n\nSee companion warning [[SC2165]].\n\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2168": {
    "remediation_points": 50000,
    "content": {
      "body": "## 'local' is only valid in functions.\n\n### Problematic code:\n\n```sh\nlocal foo=bar\necho \"$foo\"\n```\n\n### Correct code:\n\n```sh\nfoo=bar\necho \"$foo\"\n```\n### Rationale:\n\nIn Bash, `local` can only be used in functions. In other contexts, it's an error.\n\n### Exceptions:\n\nIt's possible to source files containing `local` from a function context but not from any other context. This is not good practice, but in these cases you can [[ignore]] this error.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2169": {
    "remediation_points": 50000,
    "content": {
      "body": "## In dash, [\\[ ]] is not supported.\n\nYou are writing a script for `dash`, but you're using a feature that `dash` doesn't support (in this case, bash/ksh style `[[ .. ]]` conditions). \n\nSee Ubuntu's [DashAsBinSh](https://wiki.ubuntu.com/DashAsBinSh) migration guide for how to make bash-specific scripts dash-compatible.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2170": {
    "remediation_points": 50000,
    "content": {
      "body": "## Numerical -eq does not dereference in [..]. Expand or use string operator.\n\n### Problematic code:\n\n```sh\nread -r n\nif [ n -lt 0 ]\nthen\n   echo \"bad input\"\nfi\n```\n\n### Correct code:\n\n```sh\nread -r n\nif [ \"$n\" -lt 0 ]\nthen\n   echo \"bad input\"\nfi\n```\n### Rationale:\n\nYou are comparing a string value with a numerical operator, such as `-eq`, `-ne`, `-lt` or `-gt`.\n\nIn `[[ .. ]]`, this would automatically dereference the string, looking to see if there are variables by that name.\n\nIn `[ .. ]`, which you are using, the string is just treated as an invalid number.\n\nIf you want to compare numbers, expand yourself (e.g. use `$var` instead of `var`). If you are trying to compare strings and not numbers, use `=`, `!=` `\\<` or `\\>` instead.\n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2172": {
    "remediation_points": 50000,
    "content": {
      "body": "## Trapping signals by number is not well defined. Prefer signal names.\n\n### Problematic code:\n\n```sh\ntrap myfunc 28\n```\n\n### Correct code:\n\n```sh\ntrap myfunc WINCH\n```\n### Rationale:\n\nSignal numbers can vary between platforms. Prefer signal names, which are fixed.\n\nSignal numbers 1, 2, 3, 6, 9, 14 and 15 are specified as parts of the optional POSIX XSI and ShellCheck will not warn about these. \n\n### Exceptions:\n\nNone.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  },
  "SC2173": {
    "remediation_points": 50000,
    "content": {
      "body": "## SIGKILL/SIGSTOP can not be trapped.\n\n### Problematic code:\n\n```sh\ntrap 'echo \"unkillable\"' KILL\n```\n\n### Correct code:\n\nNot applicable. This is not possible.\n\n### Rationale:\n\nSIGKILL and SIGSTOP can not be caught/ignored (according to POSIX and as implemented on platforms including Linux and FreeBSD). Trying to trap this signal has undefined results.\n\n### Exceptions:\n\nNone. If you come across one, please file an issue about it.\n\n### Notice\n\nOriginal content from the ShellCheck https://github.com/koalaman/shellcheck/wiki.\n"
    }
  }
}